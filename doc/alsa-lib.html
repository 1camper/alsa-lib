  <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
           "http://www.w3.org/TR/REC-html40/loose.dtd"><HTML>
<META NAME="GENERATOR" CONTENT="TtH 1.98">
                                                                 
  
   
<title> Advanced Linux Sound Architecture - Library API</title>
 
<H1 align=center>Advanced Linux Sound Architecture - Library API </H1>

<p>

<H3 align=center><b>Jaroslav Kysela &lt;perex@jcu.cz&#62;</b> with assistance from Alan Robinson and Fred Floberg</H3>

<p>

<H3 align=center>1998-11-11 </H3>

<p>
<center> <i>This document describes, in full detail, the Advanced Linux
Sound Architecture library API. </i>
<p>
</center>
<H1>Contents </H1><A href="#tth_sEc1"
>1&nbsp; Introduction</A><br>
<A href="#tth_sEc2"
>2&nbsp; Error Codes</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;<A href="#tth_sEc2.1"
>2.1&nbsp; Error Codes in Detail</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;<A href="#tth_sEc2.2"
>2.2&nbsp; Functions</A><br>
<A href="#tth_sEc3"
>3&nbsp; Control Interface</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;<A href="#tth_sEc3.1"
>3.1&nbsp; Low-Level Layer</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A href="#tth_sEc3.1.1"
>3.1.1&nbsp; Examples</A><br>
<A href="#tth_sEc4"
>4&nbsp; Mixer Interface</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;<A href="#tth_sEc4.1"
>4.1&nbsp; Low-Level Layer</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A href="#tth_sEc4.1.1"
>4.1.1&nbsp; Examples</A><br>
<A href="#tth_sEc5"
>5&nbsp; Digital Audio (PCM) Interface</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;<A href="#tth_sEc5.1"
>5.1&nbsp; Low-Level Layer</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A href="#tth_sEc5.1.1"
>5.1.1&nbsp; Example</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;<A href="#tth_sEc5.2"
>5.2&nbsp; PCM Loopback Interface</A><br>
<A href="#tth_sEc6"
>6&nbsp; RawMidi Interface</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;<A href="#tth_sEc6.1"
>6.1&nbsp; Low Level Layer</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A href="#tth_sEc6.1.1"
>6.1.1&nbsp; Example</A><br>
 
<p>
        <H2><A NAME="tth_sEc1">
1</A>&nbsp;&nbsp;Introduction</H2>

<p>
The Advanced Linux Sound Architecture comes with a kernel API &amp; library API.
This document describes the library API and how it interfaces with the kernel
API. The kernal API will probably never be documented in standalone form. 

<p>
Application programmers should use the library API rather than kernel API. The
Library offers 100% of the functionally of the kernel API, but add major improvements
in usability, making the application code simpler and better looking. In addition,
some of the some fixes/compatibility code may be placed in the library code
instead of the kernel driver. 

<p>
For a complete list of all variables and functions in the API you should look
at the following header files: 

<p>

<UL>
<li> /usr/include/sys/asoundlib.h

<li> /usr/include/linux/asound.h

<li> /usr/include/linux/asoundid.h
</UL>
<p>
        <H2><A NAME="tth_sEc2">
2</A>&nbsp;&nbsp;Error Codes</H2>

<p>
All functions return int (or some sort of signed value). If this value is negative
it represents an error code. Codes up to <i>SND_ERROR_BEGIN (500000)</i>
represent standard system errors. Codes equal to or greather than this value
represent sound library API errors. All error codes begin with the prefix <i>SND_ERROR_</i>. 

<p>
      <H3><A NAME="tth_sEc2.1">
2.1</A>&nbsp;&nbsp;Error Codes in Detail</H3>

<p>
 
<table border>
<tr><td align="center">SND_ERROR_UNCOMPATIBLE_VERSION</td><td align="center">500000</td></td></table>

 
<p>
This error is caused if the driver uses an incompatible kernel API for this
interface and hence the library doesn't know how this API can be used. 

<p>
      <H3><A NAME="tth_sEc2.2">
2.2</A>&nbsp;&nbsp;Functions</H3>

<p>

<H4>const char *snd_strerror(int errnum) </H4>

<p>
This function converts an error code to a string. Its functionality is the same
as the <i>strerror</i> function from the standard C library, but this function
returns error message strings for sound error codes, as well.

<p>
        <H2><A NAME="tth_sEc3">
3</A>&nbsp;&nbsp;Control Interface</H2>

<p>
The control interface gives applications various information about the currently
installed sound driver in the system. The interface should be used to detect
if another sound interface is present for a selected soundcard or, for example,
to create a list of devices (MIXER, PCM etc) from which the user can select.

<p>
      <H3><A NAME="tth_sEc3.1">
3.1</A>&nbsp;&nbsp;Low-Level Layer</H3>

<p>

<H4>int snd_cards(void)</H4>

<p>
Returns the number of soundcards present in the system, if any. Otherwise it
returns a negative value, which maps to an error code. This function will return
0 if no soundcards are detected.

<p>

<H4>unsigned int snd_cards_mask(void)</H4>

<p>
Returns the bitmap of soundcards present in the system, if any. This function
will return 0 if no soundcards are detected. The first soundcard is represented
with bit 0 (0x00000001). See the documentation on installing ALSA and /etc/conf.modules
configuration for information on assigning numbers to soundcards.

<p>

<H4>int snd_card_name(const char *name)</H4>

<p>
Returns soundcard number for appropriate soundcard name. String <i>name</i>
can contain word identification for card (ALSA driver allows the user choose
card identification using snd_id module parameter) or soundcard index (1-N)
encoded into ASCII.

<p>

<H4>int snd_ctl_open(void **handle, int card)</H4>

<p>
Creates a new handle and opens communication with the kernel sound control interface
for soundcard number <i>card</i> (0-N). The function also checks if the protocol
is compatible, so as to prevent the use of old programs with a new kernel API.
Function returns zero if successful, otherwise an error code is returned. 

<p>

<H4>int snd_ctl_close(void *handle)</H4>

<p>
Frees all resources allocated with control handle and closes the kernel sound
control interface. This function returns zero if successful, otherwise it returns
an error code.

<p>

<H4>int snd_ctl_file_descriptor(void *handle)</H4>

<p>
Returns a file descriptor for the kernel sound control interface. This function
is normally only used in very special cases. This function returns a negative
error code if an error was encountered.

<p>

<H4>int snd_ctl_hw_info(void *handle, snd_ctl_hw_info_t *info)</H4>

<p>
Fills the info structure with data about the sound hardware referenced by handle.
This function returns zero if successful, otherwise it returns an error code.

<p>

<DL compact>   <dt><b></b></dt>
	<dd>
<i>/*&nbsp;driver&nbsp;has&nbsp;MIDI&nbsp;interface&nbsp;*/&nbsp;</i>

<p>
#define&nbsp;SND_CTL_GCAPS_MIDI&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x0000001&nbsp;

<p>
<i>/*&nbsp;soundcard&nbsp;has&nbsp;synthesizer&nbsp;*/</i>

<p>
#define&nbsp;SND_CTL_LCAPS_SYNTH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x0000001

<p>
<i>/*&nbsp;soundcard&nbsp;has&nbsp;RAW&nbsp;FM/OPL3&nbsp;*/</i>

<p>
#define&nbsp;SND_CTL_LCAPS_RAWFM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x0000002
</DL>
<p>
&nbsp;

<p>

<DL compact>   <dt><b></b></dt>
	<dd>
struct&nbsp;snd_ctl_hw_info&nbsp;{

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>/*&nbsp;type&nbsp;of&nbsp;card&nbsp;-&nbsp;see&nbsp;SND_CARD_TYPE_XXXX&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;type;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>/*&nbsp;global&nbsp;capabilities&nbsp;-&nbsp;see&nbsp;SND_CTL_GCAPS_XXXX*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;gcaps;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>/*&nbsp;local&nbsp;capabilities&nbsp;&#175; &nbsp;see&nbsp;SND_CTL_LCAPS_XXXX&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;lcaps;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>/*&nbsp;count&nbsp;of&nbsp;PCM&nbsp;devices&nbsp;(0&nbsp;to&nbsp;N)&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;pcmdevs;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>/*&nbsp;count&nbsp;of&nbsp;MIXER&nbsp;devices&nbsp;(0&nbsp;to&nbsp;N)*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;mixerdevs;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>/*&nbsp;count&nbsp;of&nbsp;raw&nbsp;MIDI&nbsp;devices&nbsp;(0&nbsp;to&nbsp;N)&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;mididevs;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>/*&nbsp;ID&nbsp;of&nbsp;card&nbsp;(user&nbsp;selectable)&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;id[80];

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>/*&nbsp;name/info&nbsp;text&nbsp;about&nbsp;soundcard&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;name[80];

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>/*&nbsp;count&nbsp;of&nbsp;control&nbsp;switches&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;switches;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>/*&nbsp;reserved&nbsp;for&nbsp;future&nbsp;use&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;reserved[124];

<p>
};
</DL>
<p>

<H4>int snd_ctl_switches(void *handle)</H4>

<p>
Returns the number of control switches. In this context 'switch' means universal
control interface between kernel and application which allows various types
of control. Function returns count if successful, otherwise it returns an error
code. Return value should be zero if the soundcard doesn't have any control
switches.

<p>

<H4>int snd_ctl_switch(void *handle, const char *switch_id)</H4>

<p>
Returns the index for the switch with the name <i>switch_id</i>. This function
returns switch index if successful, otherwise it returns an error code.

<p>

<H4>int snd_ctl_switch_read(void *handle int switchn snd_ctl_switch_t
*data)</H4>

<p>
Fills the <i>*data</i> structure with data about the switch with index <i>switchn</i>.
This function returns zero if successful, otherwise it returns an error code.

<p>

<DL compact>   <dt><b></b></dt>
	<dd>
<i>/*&nbsp;0&nbsp;or&nbsp;1&nbsp;(enable&nbsp;member&nbsp;of&nbsp;union)&nbsp;*/</i>

<p>
#define&nbsp;SND_CTL_SW_TYPE_BOOLEAN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0

<p>
<i>/*&nbsp;0&nbsp;to&nbsp;255&nbsp;-&nbsp;from&nbsp;low&nbsp;to&nbsp;high&nbsp;(data8[0]&nbsp;member&nbsp;of&nbsp;union)&nbsp;*/</i>

<p>
#define&nbsp;SND_CTL_SW_TYPE_BYTE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1

<p>
<i>/*&nbsp;0&nbsp;to&nbsp;65535&nbsp;-&nbsp;from&nbsp;low&nbsp;to&nbsp;high&nbsp;(data16[0]&nbsp;member&nbsp;of&nbsp;union)&nbsp;*/</i>

<p>
#define&nbsp;SND_CTL_SW_TYPE_WORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2

<p>
<i>/*&nbsp;0&nbsp;to&nbsp;4294967296&nbsp;&#175; &nbsp;from&nbsp;low&nbsp;to&nbsp;high&nbsp;(data32[0]&nbsp;member&nbsp;of&nbsp;union)&nbsp;*/</i>

<p>
#define&nbsp;SND_CTL_SW_TYPE_DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3

<p>
<i>/*&nbsp;user&nbsp;type&nbsp;-&nbsp;no&nbsp;type&nbsp;control&nbsp;*/</i>

<p>
#define&nbsp;SND_CTL_SW_TYPE_USER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&#126;0)
</DL>
<p>
&nbsp;

<p>

<DL compact>   <dt><b></b></dt>
	<dd>
<i>/*&nbsp;well&nbsp;known&nbsp;(named)&nbsp;switches&nbsp;*/</i>

<p>
#define&nbsp;SND_CTL_SW_JOYSTICK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Joystick"

<p>
#define&nbsp;SND_CTL_SW_JOYSTICK_ADDRESS&nbsp;&nbsp;&nbsp;"Joystick&nbsp;Address"

<p>
#define&nbsp;SND_CTL_SW_JOYSTICK_SPEED&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Joystick&nbsp;Speed"
</DL>
<p>
&nbsp;

<p>

<DL compact>   <dt><b></b></dt>
	<dd>
struct&nbsp;snd_ctl_switch&nbsp;{

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>/*&nbsp;switch&nbsp;index&nbsp;(filled&nbsp;by&nbsp;application)&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;switchn;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>/*&nbsp;indentification&nbsp;of&nbsp;switch&nbsp;(for&nbsp;driver)&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;name[32];

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>/*&nbsp;type&nbsp;of&nbsp;switch&nbsp;value&nbsp;-&nbsp;See&nbsp;SND_CTL_SW_TYPE_XXXX&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;type;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>/*&nbsp;low&nbsp;range&nbsp;value&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;low;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>/*&nbsp;high&nbsp;range&nbsp;value&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;high;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;union&nbsp;{

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;enable;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>/*&nbsp;0&nbsp;=&nbsp;off&nbsp;1&nbsp;=&nbsp;on&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;data8[32];&nbsp;&nbsp;&nbsp;&nbsp;<i>/*&nbsp;8-bit&nbsp;data&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;short&nbsp;data16[16];&nbsp;&nbsp;<i>/*&nbsp;16-bit&nbsp;data&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;data32[8];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>/*&nbsp;32-bit&nbsp;data&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;value;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>/*&nbsp;reserved&nbsp;for&nbsp;future&nbsp;use&nbsp;&#175; &nbsp;must&nbsp;be&nbsp;zero&nbsp;!!!&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;reserved[32];

<p>
}
</DL>
<p>

<H4>int snd_ctl_switch_write(void *handle int switchn snd_ctl_switch_t
*data)</H4>

<p>
Writes the <i>*data</i> structure with data about the switch with index
<i>switchn</i> to kernel. This function returns zero if successful, otherwise
it returns an error code.

<p>

<H4>int snd_ctl_mixer_info(void *handle, int dev, snd_mixer_info_t *info)</H4>

<p>
Fills the *info structure with data about the mixer device. Returns zero if
successful, otherwise it returns an error code. Details about the <i>snd_mixer_info_t</i>
structure are in the <b>Mixer Interface</b> section. The argument <i>dev</i>
specifies the device number for the appropriate soundcard. Its range is 0 to
N where N is determined by <i>struct snd_ctl_hw_info-&#62;mixerdevs - 1</i>.
It should be used to collect information about mixer devices.

<p>

<H4>int snd_ctl_mixer_switches(void *handle)</H4>

<p>
Returns count of mixer switches. In this context 'switch' means universal control
interface between kernel and application which allows various types control.
This function returns count if successful, otherwise it returns an error code.
Return value should be zero if soundcard doesn't have any mixer switches.

<p>

<H4>int snd_ctl_mixer_switch(void *handle, const char *switch_id)</H4>

<p>
Returns the index for the switch with the name <i>switch_id</i>. This function
returns switch index if successful, otherwise it returns an error code.

<p>

<H4>int snd_ctl_mixer_switch_read(void *handle int switchn snd_mixer_switch_t
*data)</H4>

<p>
Fills the <i>*data</i> structure with data about the switch with index <i>switchn</i>.
This function returns zero if successful, otherwise it returns an error code.
Details about the <i>snd_mixer_switch_t</i> structure are in the <b>Mixer
Interface</b> section.

<p>

<H4>int snd_ctl_mixer_switch_write(void *handle int switchn snd_mixer_switch_t
*data)</H4>

<p>
Writes the <i>*data</i> structure with data about switch with index <i>switchn</i>
to kernel. Function returns zero if successful, otherwise it returns an error
code. Details about the <i>snd_mixer_switch_t</i> structure are in the
<b>Mixer Interface</b> Interface section.

<p>

<H4>int snd_ctl_pcm_info(void *handle, int dev, snd_pcm_info_t *info)</H4>

<p>
Fills the <i>*info</i> structure with data about the PCM device. Function
returns zero if successful, otherwise it returns an error code. Details about
the <i>snd_pcm_info_t</i> structure are in the <b>Digital Audio (PCM)</b>
Interface section. The argument <i>dev</i> selects the device number for the
sound card referenced by <i>*handle</i>. Its range is 0 to N where N is
<i>struct snd_ctl_hw_info-&#62;pcmdevs - 1</i>. This function will work if
the selected PCM device is busy, too. It should be used to collect information
about PCM devices without exclusive lock. 

<p>

<H4>int snd_ctl_pcm_playback_info(void *handle, int dev, snd_pcm_playback_info_t
*info) </H4>

<p>
Fills the <i>*info</i> structure with data about the PCM device and playback
direction. Function returns zero if successful, otherwise it returns an error
code. Details about the <i>snd_pcm_playback_info_t</i> structure are in
the <b>Digital Audio (PCM) Interface</b> section. The argument <i>dev</i>
selects the device number for the sound card referenced by <i>*handle</i>.
Its range is 0 to N where N is <i>struct snd_ctl_hw_info-&#62;pcmdevs -
1</i>. This function will work if the selected PCM device is busy, too. It should
be used to collect information about PCM devices without exclusive lock. 

<p>

<H4>int snd_ctl_pcm_playback_switches(void *handle)</H4>

<p>
Returns count of PCM playback switches. In this context 'switch' means universal
control interface between kernel and application which allows various types
of control. Function returns count if successful, otherwise it returns an error
code. Return value should be zero if sound card doesn't have any PCM playback
switch.

<p>

<H4>int snd_ctl_pcm_playback_switch(void *handle, const char *switch_id)</H4>

<p>
Returns index for switch with name <i>switch_id</i>. Function returns switch
index if successful, otherwise it returns an error code.

<p>

<H4>int snd_ctl_pcm_playback_switch_read(void *handle int switchnsnd_pcm_switch_t *data)</H4>

<p>
Fills the <i>*data</i> structure with data about switch with index <i>switchn</i>.
Function returns zero if successful, otherwise it returns an error code. Details
about the <i>snd_pcm_switch_t</i> structure are in the <b>Digital
Audio (PCM)</b> Interface section.

<p>

<H4>int snd_ctl_pcm_playback_switch_write(void *handle int switchnsnd_pcm_switch_t *data)</H4>

<p>
Writes the <i>*data</i> structure with data about switch with index <i>switchn</i>
to kernel. Function returns zero if successful, otherwise it returns an error
code. Details about the <i>snd_pcm_switch_t</i> structure are in the <b>Digital
Audio (PCM)</b> Interface section.

<p>

<H4>int snd_ctl_pcm_record_info(void *handle, int dev, snd_pcm_record_info_t
*info)</H4>

<p>
Fills the <i>*info</i> structure with data about the PCM device and record
direction. Function returns zero if successful, otherwise it returns an error
code. Details about the <i>snd_pcm_record_info_t</i> structure are in
the <b>Digital Audio (PCM) Interface</b> section. The argument <i>dev</i>
selects the device number for the sound card referenced by <i>*handle</i>.
Its range is 0 to N where N is <i>struct snd_ctl_hw_info-&#62;pcmdevs -
1</i>. This function will work if the selected PCM device is busy, too. It should
be used to collect information about PCM devices without exclusive lock. 

<p>

<H4>int snd_ctl_pcm_record_switches(void *handle)</H4>

<p>
Returns count of PCM record switches. In this context 'switch' means universal
control interface between kernel and application which allows various types
of control. Function returns count if successful, otherwise it returns an error
code. Return value should be zero if sound card doesn't have any PCM record
switch.

<p>

<H4>int snd_ctl_pcm_record_switch(void *handle, const char *switch_id)</H4>

<p>
Returns index for switch with name <i>switch_id</i>. Function returns switch
index if successful, otherwise it returns an error code.

<p>

<H4>int snd_ctl_pcm_record_switch_read(void *handle int switchnsnd_pcm_switch_t *data)</H4>

<p>
Fills the <i>*data</i> structure with data about switch with index <i>switchn</i>.
Function returns zero if successful, otherwise it returns an error code. Details
about the <i>snd_pcm_switch_t</i> structure are in the <b>Digital
Audio (PCM)</b> Interface section.

<p>

<H4>int snd_ctl_pcm_record_switch_write(void *handle int switchnsnd_pcm_switch_t *data)</H4>

<p>
Writes the <i>*data</i> structure with data about switch with index <i>switchn</i>
to kernel. Function returns zero if successful, otherwise it returns an error
code. Details about the <i>snd_pcm_switch_t</i> structure are in the <b>Digital
Audio (PCM)</b> Interface section.

<p>

<H4>int snd_ctl_rawmidi_info(void *handle, int dev, snd_rawmidi_info_t
*info)</H4>

<p>
Fills the <i>*info</i> structure with data about the rawmidi device. Function
returns zero if successful, otherwise it returns an error code. Details about
the <i>snd_rawmidi_info_t</i> structure are in the <b>RawMidi Interface</b>
section. The argument <i>dev</i> selects the device number for the sound card
referenced by <i>*handle</i>. Its range is 0 to N where N is <i>struct
snd_ctl_hw_info-&#62;mididevs - 1</i>. This function will work if the selected rawmidi
device is busy, too. It should be used to collect information about rawmidi
devices without exclusive lock. 

<p>

<H4>int snd_ctl_rawmidi_output_info(void *handle, int dev, snd_rawmidi_output_info_t
*info) </H4>

<p>
Fills the <i>*info</i> structure with data about the rawmidi device and
output direction. Function returns zero if successful, otherwise it returns
an error code. Details about the <i>snd_pcm_playback_info_t</i> structure
are in the <b>RawMidi Interface</b> section. The argument <i>dev</i> selects
the device number for the sound card referenced by <i>*handle</i>. Its range
is 0 to N where N is <i>struct snd_ctl_hw_info-&#62;mididevs - 1</i>. This
function will work if the selected rawmidi device is busy, too. It should be
used to collect information about rawmidi devices without exclusive lock. 

<p>

<H4>int snd_ctl_rawmidi_output_switches(void *handle)</H4>

<p>
Returns count of rawmidi output switches. In this context 'switch' means universal
control interface between kernel and application which allows various types
of control. Function returns count if successful, otherwise it returns an error
code. Return value should be zero if sound card doesn't have any control switch.

<p>

<H4>int snd_ctl_rawmidi_output_switch(void *handle, const char *switch_id)</H4>

<p>
Returns index for switch with name <i>switch_id</i>. Function returns switch
index if successful, otherwise it returns an error code. Return value should
be zero if sound card doesn't have any rawmidi output switch.

<p>

<H4>int snd_ctl_rawmidi_output_switch_read(void *handle int switchnsnd_rawmidi_switch_t *data)</H4>

<p>
Fills the <i>*data</i> structure with data about switch with index <i>switchn</i>.
Function returns zero if successful, otherwise it returns an error code. Details
about the <i>snd_rawmidi_switch_t</i> structure are in the <b>RawMidi
Interface</b> section.

<p>

<H4>int snd_ctl_rawmidi_output_switch_write(void *handle int switchnsnd_rawmidi_switch_t *data)</H4>

<p>
Writes the <i>*data</i> structure with data about switch with index <i>switchn</i>
to kernel. Function returns zero if successful, otherwise it returns an error
code. Details about the <i>snd_rawmidi_switch_t</i> structure are in the
<b>RawMidi Interface</b> section.

<p>

<H4>int snd_ctl_rawmidi_input_info(void *handle, int dev, snd_rawmidi_input_info_t
*info)</H4>

<p>
Fills the <i>*info</i> structure with data about the rawmidi device and
input direction. Function returns zero if successful, otherwise it returns an
error code. Details about the <i>snd_rawmidi_record_info_t</i> structure
are in the <b>RawMidi Interface</b> section. The argument <i>dev</i> selects
the device number for the sound card referenced by <i>*handle</i>. Its range
is 0 to N where N is <i>struct snd_ctl_hw_info-&#62;pcmdevs - 1</i>. This function
will work if the selected rawmidi device is busy, too. It should be used to
collect information about rawmidi devices without exclusive lock. 

<p>

<H4>int snd_ctl_rawmidi_input_switches(void *handle)</H4>

<p>
Returns count of rawmidi input switches. In this context 'switch' means universal
control interface between kernel and application which allows various types
of control. Function returns count if successful, otherwise it returns an error
code. Return value should be zero if sound card doesn't have any rawmidi input
switch.

<p>

<H4>int snd_ctl_rawmidi_input_switch(void *handle, const char *switch_id)</H4>

<p>
Returns index for switch with name <i>switch_id</i>. Function returns switch
index if successful, otherwise it returns an error code.

<p>

<H4>int snd_ctl_rawmidi_input_switch_read(void *handle int switchnsnd_pcm_switch_t *data)</H4>

<p>
Fills the <i>*data</i> structure with data about switch with index <i>switchn</i>.
Function returns zero if successful, otherwise it returns an error code. Details
about the <i>snd_rawmidi_switch_t</i> structure are in the <b>RawMidi
Interface</b> Interface section.

<p>

<H4>int snd_ctl_rawmidi_input_switch_write(void *handle int switchnsnd_pcm_switch_t *data)</H4>

<p>
Writes the <i>*data</i> structure with data about switch with index <i>switchn</i>
to kernel. Function returns zero if successful, otherwise it returns an error
code. Details about the <i>snd_rawmidi_switch_t</i> structure are in the
<b>RawMidi Interface</b> section.

<p>
       <H4><A NAME="tth_sEc3.1.1">
3.1.1</A>&nbsp;&nbsp;Examples</H4>

<p>
The following example shows how all PCM devices can be detected for the first
sound card (#0) in the system.

<p>

<DL compact>   <dt><b></b></dt>
	<dd>
int&nbsp;card&nbsp;=&nbsp;0,&nbsp;err;&nbsp;

<p>
void&nbsp;*handle;&nbsp;

<p>
snd_ctl_hw_info_t&nbsp;info;<br>

<p>
if&nbsp;((err&nbsp;=&nbsp;snd_ctl_open(&amp;handle,&nbsp;card))&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr,&nbsp;"open&nbsp;failed:&nbsp;%s\n",&nbsp;snd_strerror(err));

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;

<p>
}&nbsp;

<p>
if&nbsp;((err&nbsp;=&nbsp;snd_ctl_hw_info(handle,&nbsp;&amp;info))&nbsp;&lt;&nbsp;0)&nbsp;{

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr,&nbsp;"hw&nbsp;info&nbsp;failed:&nbsp;%s\n",

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;snd_strerror(err));&nbsp;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;snd_ctl_close(handle);

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;

<p>
}

<p>
printf("Installed&nbsp;PCM&nbsp;devices&nbsp;for&nbsp;card&nbsp;#i:&nbsp;%i\n",

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;card&nbsp;+&nbsp;1,&nbsp;info.pcmdevs);&nbsp;

<p>
snd_ctl_close(handle);&nbsp;
</DL>
<p>
        <H2><A NAME="tth_sEc4">
4</A>&nbsp;&nbsp;Mixer Interface</H2>

<p>
The Mixer Interface allows applications to change the volume level of a sound
card's input/output channels in both the linear range percentage range
(0-100) and in decibels. It also supports features like hardware mute, input
sound source, stereo signal routing etc.

<p>
      <H3><A NAME="tth_sEc4.1">
4.1</A>&nbsp;&nbsp;Low-Level Layer</H3>

<p>
Mixer devices aren't opened exclusively. This allows applications to open a
device multiple times with one or more processes.

<p>

<H4>int snd_mixer_open(void **handle, int card, int device) </H4>

<p>
Creates new handle and opens a connection to the kernel sound mixer interface
for sound card number <i>card</i> (0-N) and mixer device number <i>device</i>.
Also checks if protocol is compatible to prevent use of old programs with new
kernel API. Function returns zero if successful, otherwise it returns an error
code.

<p>

<H4>int snd_mixer_close(void *handle)</H4>

<p>
Frees all resources allocated to the mixer handle and closes its connection
to the kernel sound mixer interface. Function returns zero if successful, otherwise
it returns an error code.

<p>

<H4>int snd_mixer_file_descriptor(void *handle)</H4>

<p>
Returns the file descriptor for the connection to the kernel sound mixer interface.
This function should be used only in very special cases. Function returns a
negative error code if an error was encountered.

<p>
The file descriptor should be used for the <i>select(2)</i> synchronous multiplexer
function for determining read direction. Applications should call <i>snd_mixer_read()</i>
function if some data is waiting to be read. It is recommended that you do this,
since it leaves place for this function to handle some new kernel API specifications.

<p>

<H4>int snd_mixer_channels(void *handle) </H4>

<p>
Returns the count of mixer channels for appropriate mixer device, otherwise
the return value is negative, and signifies an error code. Never returns zero.

<p>

<H4>int snd_mixer_info(void *handle, snd_mixer_info_t *info) </H4>

<p>
Fills the <i>*info</i> structure with information about the mixer associated
with <i>*handle</i>. Returns zero if successful, otherwise it returns an
error code.

<p>

<DL compact>   <dt><b></b></dt>
	<dd>
<i>/*&nbsp;mixer&nbsp;can&nbsp;do&nbsp;only&nbsp;exclusive&nbsp;record&nbsp;*/</i>

<p>
#define&nbsp;SND_MIXER_INFO_CAP_EXCL_RECORD&nbsp;&nbsp;&nbsp;0x00000001
</DL>
<p>
&nbsp;

<p>

<DL compact>   <dt><b></b></dt>
	<dd>
struct&nbsp;snd_mixer_info&nbsp;{

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>/*&nbsp;type&nbsp;of&nbsp;sound&nbsp;card&nbsp;-&nbsp;SND_CARD_TYPE_XXXX&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;type;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>/*&nbsp;count&nbsp;of&nbsp;mixer&nbsp;devices&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;channels;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>/*&nbsp;some&nbsp;flags&nbsp;about&nbsp;this&nbsp;device&nbsp;(SND_MIXER_INFO_CAP_XXXX)&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;caps;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>/*&nbsp;ID&nbsp;of&nbsp;this&nbsp;mixer&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;id[32];

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>/*&nbsp;name&nbsp;of&nbsp;this&nbsp;device&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;name[80];

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>/*&nbsp;reserved&nbsp;for&nbsp;future&nbsp;use&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;reserved[&nbsp;32&nbsp;];

<p>
};
</DL>
<p>

<H4>int snd_mixer_switches(void *handle)</H4>

<p>
Returns count of mixer switches. In this context 'switch' means universal control
interface between kernel and application which allows various types of control.
Function returns count if successful, otherwise it returns an error code. Return
value will be zero if sound card doesn't have any mixer switch.

<p>

<H4>int snd_mixer_switch(void *handle, const char *switch_id)</H4>

<p>
Returns index for switch with name <i>switch_id</i>. Function returns switch
index if successful, otherwise it returns an error code.

<p>

<H4>int snd_mixer_switch_read(void *handle int switchn snd_mixer_switch_t
*data)</H4>

<p>
Fills the <i>*data</i> structure with data about switch with index <i>switchn</i>.
Function returns zero if successful, otherwise it returns an error code.

<p>

<DL compact>   <dt><b></b></dt>
	<dd>
<i>/*&nbsp;0&nbsp;or&nbsp;1&nbsp;(enable&nbsp;member&nbsp;of&nbsp;union)&nbsp;*/</i>

<p>
#define&nbsp;SND_MIXER_SW_TYPE_BOOLEAN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0

<p>
<i>/*&nbsp;0&nbsp;to&nbsp;255&nbsp;-&nbsp;from&nbsp;low&nbsp;to&nbsp;high&nbsp;(data8[0]&nbsp;member&nbsp;of&nbsp;union)&nbsp;*/</i>

<p>
#define&nbsp;SND_MIXER_SW_TYPE_BYTE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1

<p>
<i>/*&nbsp;0&nbsp;to&nbsp;65535&nbsp;-&nbsp;from&nbsp;low&nbsp;to&nbsp;high&nbsp;(data16[0]&nbsp;member&nbsp;of&nbsp;union)&nbsp;*/</i>

<p>
#define&nbsp;SND_MIXER_SW_TYPE_WORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2

<p>
<i>/*&nbsp;0&nbsp;to&nbsp;4294967296&nbsp;&#175; &nbsp;from&nbsp;low&nbsp;to&nbsp;high&nbsp;(data32[0]&nbsp;member&nbsp;of&nbsp;union)&nbsp;*/</i>

<p>
#define&nbsp;SND_MIXER_SW_TYPE_DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3

<p>
<i>/*&nbsp;user&nbsp;type&nbsp;-&nbsp;no&nbsp;type&nbsp;control&nbsp;*/</i>

<p>
#define&nbsp;SND_MIXER_SW_TYPE_USER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&#126;0)
</DL>
<p>
&nbsp;

<p>

<DL compact>   <dt><b></b></dt>
	<dd>
<i>/*&nbsp;well&nbsp;known&nbsp;(named)&nbsp;switches&nbsp;*/</i>

<p>
#define&nbsp;SND_MIXER_SW_LOUDNESS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Loudness"&nbsp;&nbsp;<i>/*&nbsp;bass&nbsp;boost&nbsp;*/</i>

<p>
#define&nbsp;SND_MIXER_SW_SIM_STEREO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Simulated&nbsp;Stereo&nbsp;Enhancement"

<p>
#define&nbsp;SND_MIXER_SW_3D&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"3D&nbsp;Stereo&nbsp;Enhancement"

<p>
<i>/*&nbsp;microphone&nbsp;gain&nbsp;*/</i>

<p>
#define&nbsp;SND_MIXER_SW_MIC_GAIN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"MIC&nbsp;Gain"

<p>
<i>/*&nbsp;microphone&nbsp;auto&nbsp;gain&nbsp;control&nbsp;*/</i>

<p>
#define&nbsp;SND_MIXER_SW_MIC_GAIN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"MIC&nbsp;Auto-Gain-Control"

<p>
<i>/*&nbsp;change&nbsp;microphone&nbsp;impedance&nbsp;*/</i>

<p>
#define&nbsp;SND_MIXER_SW_MIC_GAIN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Change&nbsp;MIC&nbsp;Impedance"

<p>
<i>/*&nbsp;change&nbsp;line-in&nbsp;to&nbsp;output&nbsp;*/</i>

<p>
#define&nbsp;SND_MIXER_SW_MIC_GAIN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Line&nbsp;In&nbsp;to&nbsp;Output"

<p>
#define&nbsp;SND_MIXER_SW_IEC958OUT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"IEC-958&nbsp;(S/PDIF)&nbsp;Output"

<p>
#define&nbsp;SND_MIXER_SW_IEC958IN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"IEC-958&nbsp;(S/PDIF)&nbsp;Input"
</DL>
<p>
&nbsp;

<p>

<DL compact>   <dt><b></b></dt>
	<dd>
struct&nbsp;snd_mixer_switch&nbsp;{

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>/*&nbsp;switch&nbsp;index&nbsp;(filled&nbsp;by&nbsp;application)&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;switchn;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>/*&nbsp;identification&nbsp;of&nbsp;switch&nbsp;(for&nbsp;driver)&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;name[32];

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>/*&nbsp;type&nbsp;of&nbsp;switch&nbsp;value&nbsp;&#175; &nbsp;See&nbsp;SND_CTL_SW_TYPE_XXXX&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;type;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>/*&nbsp;low&nbsp;range&nbsp;value&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;low;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>/*&nbsp;high&nbsp;range&nbsp;value&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;high;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;union&nbsp;{

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;enable;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>/*&nbsp;0&nbsp;=&nbsp;off&nbsp;1&nbsp;=&nbsp;on&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;data8[32];&nbsp;&nbsp;&nbsp;&nbsp;<i>/*&nbsp;8-bit&nbsp;data&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;short&nbsp;data16[16];&nbsp;&nbsp;<i>/*&nbsp;16-bit&nbsp;data&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;data32[8];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>/*&nbsp;32-bit&nbsp;data&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;value;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>/*&nbsp;reserved&nbsp;for&nbsp;future&nbsp;use&nbsp;&#175; &nbsp;must&nbsp;be&nbsp;zero&nbsp;!!!&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;reserved[32];

<p>
}
</DL>
<p>

<H4>int snd_mixer_switch_write(void *handle int switchn snd_mixer_switch_t
*data)</H4>

<p>
Writes the <i>*data</i> structure with data about switch with index <i>switchn</i>
to kernel. Function returns zero if successful, otherwise it returns an error
code. 

<p>

<H4>int snd_mixer_exact_mode(void *handle, int enable)</H4>

<p>
Turns on = 1 or off = 0 (by default) exact mode. This mode allows application
to set/get volume values in exact range which uses hardware. In non-exact mode
range is always from percentage 0 to 100 and driver does conversion to hardware
range. Function returns zero if successful, otherwise it returns an error code.

<p>

<H4>int snd_mixer_channel(void *handle, const char *channel_id)</H4>

<p>
Returns the channel number (index) associated with <i>channel_id</i> (channel
name), or returns an error code. Note: Below mixer channel IDs are subject to
change and will be extended if new hardware has support for other mixer input/output
channels.

<p>

<DL compact>   <dt><b></b></dt>
	<dd>
#define&nbsp;SND_MIXER_ID_MASTER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Master"

<p>
#define&nbsp;SND_MIXER_ID_MASTER1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Master&nbsp;1"

<p>
<i>/*&nbsp;digital&nbsp;master&nbsp;*/</i>

<p>
#define&nbsp;SND_MIXER_ID_MASTERD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Master&nbsp;D"

<p>
<i>/*&nbsp;second&nbsp;digital&nbsp;master&nbsp;*/</i>

<p>
#define&nbsp;SND_MIXER_ID_MASTERD1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Master&nbsp;D1"

<p>
#define&nbsp;SND_MIXER_ID_HEADPHONE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Headphone"

<p>
#define&nbsp;SND_MIXER_ID_MASTER_MONO&nbsp;&nbsp;&nbsp;"Master&nbsp;M"

<p>
#define&nbsp;SND_MIXER_ID_3D&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"3D&nbsp;Wide"

<p>
#define&nbsp;SND_MIXER_ID_3D_VOLUME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"3D&nbsp;Volume"

<p>
#define&nbsp;SND_MIXER_ID_3D_CENTER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"3D&nbsp;Center"

<p>
#define&nbsp;SND_MIXER_ID_3D_SPACE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"3D&nbsp;Space"

<p>
#define&nbsp;SND_MIXER_ID_3D_DEPTH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"3D&nbsp;Depth"

<p>
#define&nbsp;SND_MIXER_ID_BASS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Bass"

<p>
#define&nbsp;SND_MIXER_ID_TREBLE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Treble"

<p>
#define&nbsp;SND_MIXER_ID_FADER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Fader"

<p>
#define&nbsp;SND_MIXER_ID_SYNTHESIZER&nbsp;&nbsp;&nbsp;"Synth"

<p>
#define&nbsp;SND_MIXER_ID_SYNTHESIZER1&nbsp;&nbsp;"Synth&nbsp;1"

<p>
#define&nbsp;SND_MIXER_ID_FM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"FM"

<p>
#define&nbsp;SND_MIXER_ID_EFFECT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Effect"

<p>
#define&nbsp;SND_MIXER_ID_DSP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"DSP"

<p>
#define&nbsp;SND_MIXER_ID_PCM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"PCM"

<p>
#define&nbsp;SND_MIXER_ID_PCM1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"PCM&nbsp;1"

<p>
#define&nbsp;SND_MIXER_ID_LINE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Line-In"

<p>
#define&nbsp;SND_MIXER_ID_MIC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"MIC"

<p>
#define&nbsp;SND_MIXER_ID_CD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"CD"

<p>
#define&nbsp;SND_MIXER_ID_VIDEO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Video"

<p>
#define&nbsp;SND_MIXER_ID_PHONE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Phone"

<p>
#define&nbsp;SND_MIXER_ID_GAIN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Record-Gain"

<p>
#define&nbsp;SND_MIXER_ID_MIC_GAIN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Mic-Gain"

<p>
#define&nbsp;SND_MIXER_ID_IGAIN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"In-Gain"

<p>
#define&nbsp;SND_MIXER_ID_OGAIN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Out-Gain"

<p>
#define&nbsp;SND_MIXER_ID_LOOPBACK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Loopback"

<p>
#define&nbsp;SND_MIXER_ID_SPEAKER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"PC&nbsp;Speaker"

<p>
#define&nbsp;SND_MIXER_ID_MONO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Mono"

<p>
#define&nbsp;SND_MIXER_ID_MONO1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Mono&nbsp;1"

<p>
#define&nbsp;SND_MIXER_ID_MONO2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Mono&nbsp;2"

<p>
#define&nbsp;SND_MIXER_ID_AUXA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Aux&nbsp;A"

<p>
#define&nbsp;SND_MIXER_ID_AUXB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Aux&nbsp;B"

<p>
#define&nbsp;SND_MIXER_ID_AUXC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Aux&nbsp;C"
</DL>
<p>

<H4>int snd_mixer_channel_info(void *handle, int channel, snd_mixer_channel_info_t
*info) </H4>

<p>
Fills the <i>*info</i> structure. The argument <i>channel</i> specifies
channel (0 to N) for which is the info requested. Function returns zero if successful,
otherwise it returns an error code.

<p>

<DL compact>   <dt><b></b></dt>
	<dd>
<i>/*&nbsp;mixer&nbsp;channel&nbsp;is&nbsp;record&nbsp;source&nbsp;*/</i>

<p>
#define&nbsp;SND_MIXER_CINFO_CAP_RECORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x00000001

<p>
<i>/*&nbsp;mixer&nbsp;channel&nbsp;is&nbsp;stereo&nbsp;*/</i>

<p>
#define&nbsp;SND_MIXER_CINFO_CAP_STEREO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x00000002

<p>
<i>/*&nbsp;always&nbsp;set&nbsp;at&nbsp;this&nbsp;moment&nbsp;driver&nbsp;emulates&nbsp;mute&nbsp;*/</i>

<p>
#define&nbsp;SND_MIXER_CINFO_CAP_MUTE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x00000004

<p>
<i>/*&nbsp;channel&nbsp;supports&nbsp;hardware&nbsp;mute&nbsp;*/</i>

<p>
#define&nbsp;SND_MIXER_CINFO_CAP_HWMUTE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x00000008

<p>
<i>/*&nbsp;channel&nbsp;does&nbsp;digital&nbsp;(not&nbsp;analog)&nbsp;mixing&nbsp;*/</i>

<p>
#define&nbsp;SND_MIXER_CINFO_CAP_DIGITAL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x00000010

<p>
<i>/*&nbsp;external&nbsp;input&nbsp;channel&nbsp;*/</i>

<p>
#define&nbsp;SND_MIXER_CINFO_CAP_INPUT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x00000020

<p>
<i>/*&nbsp;join&nbsp;mute&nbsp;is&nbsp;supported&nbsp;only&nbsp;*/</i>

<p>
<i>/*&nbsp;left&nbsp;and&nbsp;right&nbsp;channel&nbsp;doesn't&nbsp;have&nbsp;separate&nbsp;mute&nbsp;control&nbsp;*/</i>

<p>
#define&nbsp;SND_MIXER_CINFO_CAP_JOINMUTE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x00000040

<p>
<i>/*&nbsp;join&nbsp;record&nbsp;is&nbsp;supported&nbsp;only&nbsp;*</i>

<p>
<i>/*&nbsp;left&nbsp;and&nbsp;right&nbsp;channel&nbsp;doesn't&nbsp;have&nbsp;separate&nbsp;record&nbsp;control&nbsp;*/</i>

<p>
#define&nbsp;SND_MIXER_CINFO_CAP_JOINRECORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x00000080

<p>
<i>/*&nbsp;route&nbsp;left&nbsp;input&nbsp;to&nbsp;right&nbsp;output&nbsp;is&nbsp;supported&nbsp;*/</i>

<p>
#define&nbsp;SND_MIXER_CINFO_CAP_LTOR_OUT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x00000100

<p>
<i>/*&nbsp;route&nbsp;right&nbsp;input&nbsp;to&nbsp;left&nbsp;output&nbsp;is&nbsp;supported&nbsp;*/</i>

<p>
#define&nbsp;SND_MIXER_CINFO_CAP_RTOL_OUT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x00000200

<p>
<i>/*&nbsp;route&nbsp;left&nbsp;input&nbsp;to&nbsp;right&nbsp;ADC&nbsp;is&nbsp;supported&nbsp;*/</i>

<p>
#define&nbsp;SND_MIXER_CINFO_CAP_LTOR_IN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x00000400

<p>
<i>/*&nbsp;route&nbsp;right&nbsp;input&nbsp;to&nbsp;left&nbsp;ADC&nbsp;is&nbsp;supported&nbsp;*/</i>

<p>
#define&nbsp;SND_MIXER_CINFO_CAP_RTOL_IN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x00000800

<p>
<i>/*&nbsp;output&nbsp;route&nbsp;is&nbsp;only&nbsp;switch&nbsp;(cannot&nbsp;be&nbsp;used&nbsp;separately)&nbsp;*/</i>

<p>
#define&nbsp;SND_MIXER_CINFO_CAP_SWITCH_OUT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x00001000

<p>
<i>/*&nbsp;input&nbsp;route&nbsp;is&nbsp;only&nbsp;switch&nbsp;(cannot&nbsp;be&nbsp;used&nbsp;separately)&nbsp;*/</i>

<p>
#define&nbsp;SND_MIXER_CINFO_CAP_SWITCH_IN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x00002000

<p>
<i>/*&nbsp;data&nbsp;can&nbsp;be&nbsp;recorded&nbsp;even&nbsp;if&nbsp;output&nbsp;path&nbsp;is&nbsp;muted&nbsp;*/</i>

<p>
<i>/*&nbsp;(to&nbsp;avoid&nbsp;loopback)&nbsp;*/</i>

<p>
#define&nbsp;SND_MIXER_CINFO_CAP_RECORDBYMUTE&nbsp;&nbsp;&nbsp;0x00004000
</DL>
<p>
&nbsp;

<p>

<DL compact>   <dt><b></b></dt>
	<dd>
struct&nbsp;snd_mixer_channel_info&nbsp;{

<p>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;channel&nbsp;index&nbsp;(filled&nbsp;by&nbsp;application)&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;channel;

<p>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;parent&nbsp;channel&nbsp;#&nbsp;or&nbsp;SND_MIXER_PARENT&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;parent;

<p>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;name&nbsp;of&nbsp;this&nbsp;device&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;name[12];

<p>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;some&nbsp;flags&nbsp;about&nbsp;this&nbsp;device&nbsp;(SND_MIXER_CINFO_XXXX)&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;caps;

<p>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;min.&nbsp;value&nbsp;when&nbsp;exact&nbsp;mode&nbsp;(or&nbsp;always&nbsp;0)&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;min;&nbsp;

<p>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;max.&nbsp;value&nbsp;when&nbsp;exact&nbsp;mode&nbsp;(or&nbsp;always&nbsp;100)&nbsp;*/&nbsp;</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;max;

<p>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;minimum&nbsp;decibel&nbsp;value&nbsp;(*100)&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;min_dB;

<p>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;maximum&nbsp;decibel&nbsp;value&nbsp;(*100)&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;max_dB;

<p>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;step&nbsp;decibel&nbsp;value&nbsp;(*100)&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;step_dB;

<p>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;reserved&nbsp;for&nbsp;future&nbsp;use&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;reserved[16];

<p>
};
</DL>
<p>

<H4>int snd_mixer_channel_read(void *handle, int channel, snd_mixer_channel_t
*data) </H4>

<p>
Fills the <i>*data</i> structure. The argument <i>channel</i> specifies
the channel (0 to N) for which is data requested. Function returns zero if successful,
otherwise it returns an error code.

<p>

<DL compact>   <dt><b></b></dt>
	<dd>
/*&nbsp;channel&nbsp;record&nbsp;source&nbsp;flags&nbsp;*/

<p>
#define&nbsp;SND_MIXER_FLG_RECORD_LEFT&nbsp;&nbsp;0x00000001

<p>
#define&nbsp;SND_MIXER_FLG_RECORD_RIGHT&nbsp;0x00000002

<p>
#define&nbsp;SND_MIXER_FLG_RECORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x00000003

<p>
/*&nbsp;mute&nbsp;channel&nbsp;flags&nbsp;*/

<p>
#define&nbsp;SND_MIXER_FLG_MUTE_LEFT&nbsp;&nbsp;&nbsp;&nbsp;0x00010000

<p>
#define&nbsp;SND_MIXER_FLG_MUTE_RIGHT&nbsp;&nbsp;&nbsp;0x00020000

<p>
#define&nbsp;SND_MIXER_FLG_MUTE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x00030000

<p>
/*&nbsp;input&nbsp;to&nbsp;output&nbsp;route&nbsp;setup&nbsp;*/

<p>
#define&nbsp;SND_MIXER_FLG_LTOR_OUT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x00100000

<p>
#define&nbsp;SND_MIXER_FLG_RTOL_OUT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x00200000

<p>
#define&nbsp;SND_MIXER_FLG_SWITCH_OUT&nbsp;&nbsp;&nbsp;0x00300000

<p>
/*&nbsp;input&nbsp;to&nbsp;ADC&nbsp;route&nbsp;setup&nbsp;*/

<p>
#define&nbsp;SND_MIXER_FLG_LTOR_IN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x00400000

<p>
#define&nbsp;SND_MIXER_FLG_RTOL_IN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x00800000

<p>
#define&nbsp;SND_MIXER_FLG_SWITCH_IN&nbsp;&nbsp;&nbsp;&nbsp;0x00c00000

<p>
/*&nbsp;set&nbsp;volume&nbsp;in&nbsp;decibels&nbsp;from&nbsp;dB&nbsp;variables&nbsp;*/

<p>
#define&nbsp;SND_MIXER_FLG_DECIBEL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x40000000

<p>
/*&nbsp;reserved&nbsp;for&nbsp;kernel&nbsp;use,&nbsp;don't&nbsp;use&nbsp;this&nbsp;flag&nbsp;from&nbsp;application&nbsp;*/

<p>
#define&nbsp;SND_MIXER_FLG_FORCE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x80000000
</DL>
<p>
&nbsp;

<p>

<DL compact>   <dt><b></b></dt>
	<dd>
struct&nbsp;snd_mixer_channel&nbsp;{

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;channel&nbsp;#&nbsp;(filled&nbsp;by&nbsp;application)&nbsp;*/

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;channel;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;some&nbsp;flags&nbsp;to&nbsp;read/write&nbsp;(SND_MIXER_FLG_XXXX)&nbsp;*/

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;flags;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;min&nbsp;-&nbsp;max&nbsp;when&nbsp;exact&nbsp;mode&nbsp;(or&nbsp;0&nbsp;-&nbsp;100)&nbsp;*/

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;left;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;min&nbsp;-&nbsp;max&nbsp;when&nbsp;exact&nbsp;mode&nbsp;(or&nbsp;0&nbsp;-&nbsp;100)&nbsp;*/&nbsp;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;right;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;dB&nbsp;*&nbsp;100&nbsp;*/

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;left_dB;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;dB&nbsp;*&nbsp;100&nbsp;*/

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;right_dB;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;reserved[16];

<p>
};&nbsp;
</DL>
<p>

<H4>int snd_mixer_channel_write(void *handle, int channel, snd_mixer_channel_t
*data)</H4>

<p>
Writes the <i>*data</i> structure to kernel. The <i>channel</i> argument
specifies the channel (0 to N) for which is data is to be applied. Function
returns zero if successful, otherwise it returns an error code. This functions
is the opposite of <i>snd_mixer_channel_read</i>.

<p>

<H4>int snd_mixer_read(void *handle, snd_mixer_callbacks_t *callbacks)</H4>

<p>
This function reads and parses data from driver. Parsed actions are returned
back to the application using the <i>callbacks</i> structure. Applications
should not parse data from the driver in standard cases. This function returns
immediately after all data is read from driver. Does not block process.

<p>

<DL compact>   <dt><b></b></dt>
	<dd>
typedef&nbsp;struct&nbsp;snd_mixer_callbacks&nbsp;{

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;should&nbsp;be&nbsp;used&nbsp;by&nbsp;application&nbsp;*/

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*private_data;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;(*channel_was_changed)(void&nbsp;*private_data,&nbsp;int&nbsp;channel);

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;(*switch_was_changed)(void&nbsp;*private_data,&nbsp;int&nbsp;switchn);

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;reserved&nbsp;for&nbsp;future&nbsp;use&nbsp;-&nbsp;must&nbsp;be&nbsp;NULL!!!&nbsp;*/&nbsp;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*reserved[14];

<p>
}&nbsp;snd_mixer_callbacks_t;
</DL>
<p>
       <H4><A NAME="tth_sEc4.1.1">
4.1.1</A>&nbsp;&nbsp;Examples</H4>

<p>
The following example shows installed mixer channels for sound card #0 and
mixer device #0 in the system, and also sets the master volume (if present)
to 50.

<p>

<DL compact>   <dt><b></b></dt>
	<dd>
int&nbsp;card&nbsp;=&nbsp;0,&nbsp;device&nbsp;=&nbsp;0,&nbsp;err;

<p>
void&nbsp;*handle;

<p>
snd_mixer_info_t&nbsp;info;

<p>
snd_mixer_channel_t&nbsp;channel;
</DL>
<p>
&nbsp;

<p>

<DL compact>   <dt><b></b></dt>
	<dd>
if&nbsp;((err&nbsp;=&nbsp;snd_mixer_open(&amp;handle,&nbsp;card,&nbsp;device))&nbsp;&lt;&nbsp;0)&nbsp;{

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr,&nbsp;"open&nbsp;failed:&nbsp;%s\n",&nbsp;snd_strerror(err));

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;

<p>
}

<p>
if&nbsp;((err&nbsp;=&nbsp;snd_mixer_info(handle,&nbsp;&amp;info))&nbsp;&lt;&nbsp;0)&nbsp;{

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr,&nbsp;"info&nbsp;failed:&nbsp;%s\n",&nbsp;snd_strerror(err));&nbsp;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;snd_mixer_close(handle);

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;

<p>
}

<p>
printf("Installed&nbsp;MIXER&nbsp;channels&nbsp;for&nbsp;card&nbsp;#i&nbsp;and&nbsp;device&nbsp;%i:&nbsp;%i\n",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;card&nbsp;+&nbsp;1,&nbsp;device,&nbsp;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;info.channels);

<p>
master&nbsp;=&nbsp;snd_mixer_channel(handle,&nbsp;SND_MIXER_ID_MASTER);

<p>
if&nbsp;(master&nbsp;&#62;=&nbsp;0)&nbsp;{

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;((err&nbsp;=&nbsp;snd_mixer_read(handle,&nbsp;master,&nbsp;&amp;channel))&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr,&nbsp;"master&nbsp;read&nbsp;failed:&nbsp;%s\n",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;snd_strerror(&nbsp;err&nbsp;));&nbsp;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;snd_mixer_close(&nbsp;handle&nbsp;);

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;channel.left&nbsp;=&nbsp;channel.right&nbsp;=&nbsp;50;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;((err&nbsp;=&nbsp;snd_mixer_write(handle,&nbsp;master,&nbsp;&amp;channel))&nbsp;&lt;&nbsp;0&nbsp;)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr,&nbsp;"master&nbsp;write&nbsp;failed:&nbsp;%s\n",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;snd_strerror(&nbsp;err&nbsp;));&nbsp;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;snd_mixer_close(handle);

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

<p>
}

<p>
snd_mixer_close(handle);
</DL>
<p>
        <H2><A NAME="tth_sEc5">
5</A>&nbsp;&nbsp;Digital Audio (PCM) Interface</H2>

<p>
Digital audio is the most commonly used method of representing sound inside
a computer. In this method sound is stored as a sequence of samples taken from
the audio signal using constant time intervals. A sample represents volume of
the signal at the moment when it was measured. In uncompressed digital audio
each sample require one or more bytes of storage. The number of bytes required
depends on number of channels (mono, stereo) and sample format (8 or 16 bits,
mu-Law, etc.). The length of this interval determines the sampling rate. Commonly
used sampling rates are between 8 kHz (telephone quality) and 48 kHz (DAT tapes).

<p>
The physical devices used in digital audio are called the ADC (Analog to Digital
Converter) and DAC (Digital to Analog Converter). A device containing both ADC
and DAC is commonly known as a codec. The codec device used in a Sound Blaster
cards is called a DSP which is somewhat misleading since DSP also stands for
Digital Signal Processor (the SB DSP chip is very limited when compared to "true"
DSP chips).

<p>
Sampling parameters affect the quality of sound which can be reproduced from
the recorded signal. The most fundamental parameter is sampling rate which limits
the highest frequency that can be stored. It is well known (Nyquist's Sampling
Theorem) that the highest frequency that can be stored in a sampled signal is
at most 1/2 of the sampling frequency. For example, an 8 kHz sampling rate permits
the recording of a signal in which the highest frequency is less than 4 kHz.
Higher frequency signals must be filtered out before feeding them to DAC.

<p>
Sample encoding limits the dynamic range of a recorded signal (difference between
the faintest and the loudest signal that can be recorded). In theory the maximum
dynamic range of signal is number_of_bits * 6 dB . This means that 8 bits
sampling resolution gives dynamic range of 48 dB and 16 bit resolution gives
96 dB.

<p>
Quality has price. The number of bytes required to store an audio sequence depends
on sampling rate, number of channels and sampling resolution. For example just
8000 bytes of memory is required to store one second of sound using 8 kHz/8
bits/mono but 48 kHz/16bit/stereo takes 192 kilobytes. A 64 kbps ISDN channel
is required to transfer a 8kHz/8bit/mono audio stream in real time, and about
1.5 Mbps is required for DAT quality (48kHz/16bit/stereo). On the other hand
it is possible to store just 5.46 seconds of sound in a megabyte of memory when
using 48kHz/16bit/stereo sampling. With 8kHz/8bits/mono it is possible to store
131 seconds of sound using the same amount of memory. It is possible to reduce
memory and communication costs by compressing the recorded signal but this is
beyond the scope of this document. 

<p>
      <H3><A NAME="tth_sEc5.1">
5.1</A>&nbsp;&nbsp;Low-Level Layer</H3>

<p>
Audio devices are opened exclusively for a selected direction. This doesn't
allow open from more than one processes for the same audio device in the same
direction, but does allow one open call to each playback direction and second
open call to record direction independently. Audio devices return EBUSY error
to applications when other applications have already opened the requested direction.

<p>
Low-Level layer supports these formats:

<p>

<DL compact>   <dt><b></b></dt>
	<dd>
<i>/*&nbsp;muLaw&nbsp;compressed&nbsp;samples&nbsp;*/</i>

<p>
#define&nbsp;SND_PCM_SFMT_MU_LAW&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0

<p>
<i>/*&nbsp;aLaw&nbsp;compressed&nbsp;samples&nbsp;*/</i>

<p>
#define&nbsp;SND_PCM_SFMT_A_LAW&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1

<p>
<i>/*&nbsp;Ima-ADPM&nbsp;4:1&nbsp;compressed&nbsp;samples&nbsp;*/</i>

<p>
#define&nbsp;SND_PCM_SFMT_IMA_ADPCM&nbsp;&nbsp;&nbsp;&nbsp;2

<p>
<i>/*&nbsp;Unsigned&nbsp;8-bit&nbsp;samples&nbsp;(most&nbsp;common&nbsp;8-bit&nbsp;format)&nbsp;*/</i>

<p>
#define&nbsp;SND_PCM_SFMT_U8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3

<p>
<i>/*&nbsp;Signed&nbsp;16-bit&nbsp;Little&nbsp;Endian&nbsp;samples&nbsp;(most&nbsp;common&nbsp;16-bit&nbsp;format)&nbsp;*/</i>

<p>
#define&nbsp;SND_PCM_SFMT_S16_LE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4

<p>
<i>/*&nbsp;Signed&nbsp;16-bit&nbsp;Big&nbsp;Endian&nbsp;samples&nbsp;*/</i>

<p>
#define&nbsp;SND_PCM_SFMT_S16_BE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5

<p>
<i>/*&nbsp;Signed&nbsp;8-bit&nbsp;samples&nbsp;*/</i>

<p>
#define&nbsp;SND_PCM_SFMT_S8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6

<p>
<i>/*&nbsp;Unsigned&nbsp;16-bit&nbsp;Little&nbsp;Endian&nbsp;samples&nbsp;*/</i>

<p>
#define&nbsp;SND_PCM_SFMT_U16_LE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7

<p>
<i>/*&nbsp;Unsigned&nbsp;16-bit&nbsp;Big&nbsp;Endian&nbsp;samples&nbsp;*/</i>

<p>
#define&nbsp;SND_PCM_SFMT_U16_BE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8

<p>
<i>/*&nbsp;MPEG&nbsp;1/2&nbsp;stream&nbsp;*/</i>

<p>
#define&nbsp;SND_PCM_SFMT_MPEG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9

<p>
<i>/*&nbsp;GSM&nbsp;stream&nbsp;*/</i>

<p>
#define&nbsp;SND_PCM_SFMT_GSM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10
</DL>
<p>
&nbsp;

<p>

<DL compact>   <dt><b></b></dt>
	<dd>
#define&nbsp;SND_PCM_FMT_MU_LAW&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1&nbsp;&lt;&lt;&nbsp;SND_PCM_SFMT_MU_LAW)

<p>
#define&nbsp;SND_PCM_FMT_A_LAW&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1&nbsp;&lt;&lt;&nbsp;SND_PCM_SFMT_A_LAW)

<p>
#define&nbsp;SND_PCM_FMT_IMA_ADPCM&nbsp;&nbsp;&nbsp;&nbsp;(1&nbsp;&lt;&lt;&nbsp;SND_PCM_SFMT_IMA_ADPCM)

<p>
#define&nbsp;SND_PCM_FMT_U8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1&nbsp;&lt;&lt;&nbsp;SND_PCM_SFMT_U8)

<p>
#define&nbsp;SND_PCM_FMT_S16_LE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1&nbsp;&lt;&lt;&nbsp;SND_PCM_SFMT_S16_LE)

<p>
#define&nbsp;SND_PCM_FMT_S16_BE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1&nbsp;&lt;&lt;&nbsp;SND_PCM_SFMT_S16_BE)

<p>
#define&nbsp;SND_PCM_FMT_S8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1&nbsp;&lt;&lt;&nbsp;SND_PCM_SFMT_S8)

<p>
#define&nbsp;SND_PCM_FMT_U16_LE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1&nbsp;&lt;&lt;&nbsp;SND_PCM_SFMT_U16_LE)

<p>
#define&nbsp;SND_PCM_FMT_U16_BE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1&nbsp;&lt;&lt;&nbsp;SND_PCM_SFMT_U16_BE)

<p>
#define&nbsp;SND_PCM_FMT_MPEG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1&nbsp;&lt;&lt;&nbsp;SND_PCM_SFMT_MPEG)

<p>
#define&nbsp;SND_PCM_FMT_GSM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1&nbsp;&lt;&lt;&nbsp;SND_PCM_SFMT_GSM)
</DL>
<p>
Constants with prefix <i>SND_PCM_FMT_</i> are used in info structures and
constants with prefix <i>SND_PCM_SFMT_</i> are used in format structures.

<p>
ALSA PCM API uses an enhanced double buffering scheme. This allows the user
to implement a more comfortable buffer setup. Audio buffer is separated to small
fragments. Each fragment has the same size. Application can set wakeup limits
like ``I want to get recorded data when at least two fragments with size 160
bytes are filled.''. For more information you should see description of <i>snd_pcm_*_params_t</i>
and <i>snd_pcm_*_status_t</i> structures and the <em>snd_pcm_playback_status(),
snd_pcm_record_status()</em> functions, documented below.

<p>

<H4>int snd_pcm_open(void **handle, int card, int device, int mode)</H4>

<p>
Creates a new handle and opens a connection to the kernel sound audio interface
for sound card number <i>card</i> (0-N) and audio device number <i>device</i>.
Function also checks if protocol is compatible to prevent use of old programs
with a new kernel API. Function returns zero if successful otherwise it returns
an error code. Error code -EBUSY is returned when some process owns the selected
direction.

<p>
Default format after opening is mono <i>mu-Law</i> at 8000Hz. This device
can be used directly for playback of standard .au (Sparc) files. 

<p>
The following modes should be used for the <i>mode</i> argument: 

<p>

<DL compact>   <dt><b></b></dt>
	<dd>
#define&nbsp;SND_PCM_OPEN_PLAYBACK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(O_WRONLY)

<p>
#define&nbsp;SND_PCM_OPEN_RECORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(O_RDONLY)

<p>
#define&nbsp;SND_PCM_OPEN_DUPLEX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(O_RDWR)
</DL>
<p>

<H4>int snd_pcm_close(void *handle)</H4>

<p>
Frees all resources allocated with audio handle and closes the connection to
the kernel sound audio interface. Function returns zero if successful, otherwise
it returns an error code.

<p>

<H4>int snd_pcm_file_descriptor(void *handle)</H4>

<p>
Returns the file descriptor of the connection to the kernel sound audio interface.
Function returns an error code if an error was encountered.

<p>
The file descriptor should be used for the <i>select(2)</i> synchronous multiplexer
function for setting the read direction. Application should call <i>snd_pcm_read()</i>
or <i>snd_pcm_write()</i> functions if data is waiting to be read or a write
can be performed. Calling these functions is highly recommended, as it leaves
a place for the API to do things like data conversions, if needed.

<p>

<H4>int snd_pcm_block_mode(void *handle, int enable) </H4>

<p>
Sets up block (default) or non-block mode for a handle. Block mode suspends
execution of a program when <i>snd_pcm_read()</i> or <i>snd_pcm_write()</i>
is called for the time which is needed for the actual playback or record over
of the selected limit. In non-block mode, programs aren't suspended and the
above functions return immediately with the count of bytes which were read or
written by the driver. When used in this way, don't try to use the entire buffer
after the call, but instead process the number of bytes returned, and call the
function again.

<p>

<H4>int snd_pcm_info(void *handle, snd_pcm_info_t *info)</H4>

<p>
Fills the <i>*info</i> structure with data about the PCM device selected
by <i>*handle</i>. Function returns zero if successful, otherwise it returns
an error code.

<p>

<DL compact>   <dt><b></b></dt>
	<dd>
<i>/*&nbsp;hardware&nbsp;have&nbsp;codec&nbsp;*/</i>

<p>
#define&nbsp;SND_PCM_INFO_CODEC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x00000001

<p>
#define&nbsp;SND_PCM_INFO_DSP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SND_PCM_INFO_CODEC

<p>
<i>/*&nbsp;this&nbsp;flag&nbsp;is&nbsp;reserved&nbsp;and&nbsp;should&nbsp;be&nbsp;never&nbsp;used&nbsp;*/</i>

<p>
<i>/*&nbsp;It&nbsp;remains&nbsp;for&nbsp;compatibility&nbsp;with&nbsp;Open&nbsp;Sound&nbsp;System&nbsp;driver.&nbsp;*/</i>

<p>
#define&nbsp;SND_PCM_INFO_MMAP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x00000002

<p>
<i>/*&nbsp;playback&nbsp;direction&nbsp;is&nbsp;supported&nbsp;*/</i>

<p>
#define&nbsp;SND_PCM_INFO_PLAYBACK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x00000100

<p>
<i>/*&nbsp;record&nbsp;direction&nbsp;is&nbsp;supported&nbsp;*/</i>

<p>
#define&nbsp;SND_PCM_INFO_RECORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x00000200

<p>
#define&nbsp;SND_PCM_INFO_DUPLEX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x00000400

<p>
<i>/*&nbsp;rate&nbsp;for&nbsp;playback&nbsp;&amp;&nbsp;record&nbsp;must&nbsp;be&nbsp;same&nbsp;*/</i>

<p>
#define&nbsp;SND_PCM_INFO_DUPLEX_LIMIT&nbsp;&nbsp;&nbsp;0x00000800

<p>
<i>/*&nbsp;duplex&nbsp;is&nbsp;supported&nbsp;only&nbsp;by&nbsp;mono&nbsp;(one&nbsp;channel)&nbsp;format&nbsp;*/</i>

<p>
#define&nbsp;SND_PCM_INFO_DUPLEX_MONO&nbsp;&nbsp;&nbsp;&nbsp;0x00001000
</DL>
<p>
&nbsp;

<p>

<DL compact>   <dt><b></b></dt>
	<dd>
struct&nbsp;snd_pcm_info&nbsp;{

<p>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;sound&nbsp;card&nbsp;type&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;type;

<p>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;see&nbsp;SND_PCM_INFO_XXXX&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;flags;

<p>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;ID&nbsp;of&nbsp;this&nbsp;PCM&nbsp;device&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;id[32];

<p>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;name&nbsp;of&nbsp;this&nbsp;device&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;name[80];

<p>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;reserved&nbsp;for&nbsp;future&nbsp;use&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;reserved[64];

<p>
};
</DL>
<p>

<H4>int snd_pcm_playback_info(void *handle, snd_pcm_playback_info_t *info)</H4>

<p>
Fills the *info structure with data about PCM playback. Function returns zero
if successful, otherwise it returns an error code.

<p>

<DL compact>   <dt><b></b></dt>
	<dd>
#define&nbsp;SND_PCM_PINFO_BATCH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x00000001

<p>
#define&nbsp;SND_PCM_PINFO_8BITONLY&nbsp;&nbsp;&nbsp;0x00000002

<p>
#define&nbsp;SND_PCM_PINFO_16BITONLY&nbsp;&nbsp;0x00000004
</DL>
<p>
&nbsp;

<p>

<DL compact>   <dt><b></b></dt>
	<dd>
struct&nbsp;snd_pcm_playback_info&nbsp;{

<p>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;see&nbsp;SND_PCM_PINFO_XXXX&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;flags;

<p>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;supported&nbsp;formats&nbsp;*/&nbsp;</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;formats;

<p>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;min&nbsp;rate&nbsp;(in&nbsp;Hz)&nbsp;*/&nbsp;</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;min_rate;

<p>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;max&nbsp;rate&nbsp;(in&nbsp;Hz)&nbsp;*/&nbsp;</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;max_rate;

<p>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;min&nbsp;channels&nbsp;-&nbsp;voices&nbsp;(probably&nbsp;always&nbsp;1)&nbsp;*/&nbsp;</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;min_channels;

<p>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;max&nbsp;channels&nbsp;-&nbsp;voices&nbsp;*/&nbsp;</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;max_channels;

<p>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;playback&nbsp;buffer&nbsp;size&nbsp;in&nbsp;bytes&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;buffer_size;

<p>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;min&nbsp;fragment&nbsp;size&nbsp;in&nbsp;bytes&nbsp;*/&nbsp;</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;min_fragment_size;

<p>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;max&nbsp;fragment&nbsp;size&nbsp;in&nbsp;bytes&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;max_fragment_size;

<p>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;align&nbsp;fragment&nbsp;value&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;fragment_align;

<p>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;supported&nbsp;formats&nbsp;directly&nbsp;by&nbsp;hardware&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;hw_formats;

<p>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;count&nbsp;of&nbsp;playback&nbsp;switches&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;switches;

<p>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;reserved&nbsp;for&nbsp;future&nbsp;use&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;reserved[56];

<p>
};
</DL>
<p>

<DL compact><dt><b></b></dt>
	<dd> [SND_PCM_PINFO_BATCH]Driver implements double buffering with this device.
This means that the chip used for data processing has its own memory, and output
will be more delayed than if a traditional codec chip is used.
<dt><b></b></dt>
	<dd> [SND_PCM_PINFO_8BITONLY]If this bit is set, the driver uses 8-bit format
for 16-bit samples and does software conversion. This bit is set on broken SoundBlaster
16/AWE sound cards which can't do full 16-bit duplex. If this bit is set application
or higher digital audio layer should do the conversion from 16-bit samples to
8-bit samples rather than making the driver to do it in the kernel.
<dt><b></b></dt>
	<dd> [SND_PCM_PINFO_16BITONLY]If this bit is set, driver uses 16-bit format for
8-bit samples and does software conversion. This bit is set on broken SoundBlaster
16/AWE sound cards which can't do full 8-bit duplex. If this bit is set the
application or higher digital audio layer should do conversion from 8-bit samples
to 16-bit samples rather than making the driver to do it in the kernel. 
</DL>
<p>

<H4>int snd_pcm_record_info(void *handle, snd_pcm_record_info_t *info)</H4>

<p>
Fills the *info structure. Returns zero if successful, otherwise it returns
an error code. 

<p>

<DL compact>   <dt><b></b></dt>
	<dd>
#define&nbsp;SND_PCM_RINFO_BATCH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x00000001

<p>
#define&nbsp;SND_PCM_RINFO_8BITONLY&nbsp;&nbsp;&nbsp;0x00000002

<p>
#define&nbsp;SND_PCM_RINFO_16BITONLY&nbsp;&nbsp;0x00000004

<p>
#define&nbsp;SND_PCM_RINFO_OVERRANGE&nbsp;&nbsp;0x00001000
</DL>
<p>
&nbsp;

<p>

<DL compact>   <dt><b></b></dt>
	<dd>
struct&nbsp;snd_pcm_record_info&nbsp;{

<p>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;see&nbsp;SND_PCM_RINFO_XXXX&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;flags;

<p>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;supported&nbsp;formats&nbsp;*/&nbsp;</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;formats;

<p>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;min&nbsp;rate&nbsp;(in&nbsp;Hz)&nbsp;*/&nbsp;</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;min_rate;

<p>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;max&nbsp;rate&nbsp;(in&nbsp;Hz)&nbsp;*/&nbsp;</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;max_rate;

<p>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;min&nbsp;channels&nbsp;-&nbsp;voices&nbsp;(probably&nbsp;always&nbsp;1)&nbsp;*/&nbsp;</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;min_channels;

<p>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;max&nbsp;channels&nbsp;-&nbsp;voices&nbsp;*/&nbsp;</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;max_channels;

<p>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;playback&nbsp;buffer&nbsp;size&nbsp;in&nbsp;bytes&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;buffer_size;

<p>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;min&nbsp;fragment&nbsp;size&nbsp;in&nbsp;bytes&nbsp;*/&nbsp;</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;min_fragment_size;

<p>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;max&nbsp;fragment&nbsp;size&nbsp;in&nbsp;bytes&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;max_fragment_size;

<p>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;align&nbsp;fragment&nbsp;value&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;fragment_align;

<p>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;supported&nbsp;formats&nbsp;directly&nbsp;by&nbsp;hardware&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;hw_formats;

<p>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;count&nbsp;of&nbsp;record&nbsp;switches&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;switches;

<p>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;reserved&nbsp;for&nbsp;future&nbsp;use&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;reserved[56];

<p>
};
</DL>
<p>

<DL compact><dt><b></b></dt>
	<dd> [SND_PCM_RINFO_BATCH]Driver implements double buffering with this device.
This means that the chip used for data processing has its own memory, and input
will be more delayed than if a traditional codec chip is used.
<dt><b></b></dt>
	<dd> [SND_PCM_RINFO_8BITONLY]If this bit is set, the driver uses 8-bit format
for 16-bit samples and does software conversion. This bit is set on broken SoundBlaster
16/AWE sound cards which can't do full 16-bit duplex. If this bit is set application
or higher digital audio layer should do the conversion from 16-bit samples to
8-bit samples rather than making the driver to do it in the kernel.
<dt><b></b></dt>
	<dd> [SND_PCM_RINFO_16BITONLY]If this bit is set, driver uses 16-bit format for
8-bit samples and does software conversion. This bit is set on broken SoundBlaster
16/AWE sound cards which can't do full 8-bit duplex. If this bit is set the
application or higher digital audio layer should do conversion from 8-bit samples
to 16-bit samples rather than making the driver to do it in the kernel. 
<dt><b></b></dt>
	<dd> [SND_PCM_RINFO_OVERRANGE]If this bit is set the hardware can do ADC
over-range detection.
</DL>
<p>

<H4>int snd_pcm_playback_switches(void *handle)</H4>

<p>
Returns count of PCM playback switches. In this contents switch means universal
control interface between kernel and application which allows variable type
control. Function returns count if successful, otherwise it returns an error
code. Return value should be zero if sound card doesn't have any PCM playback
switch.

<p>

<H4>int snd_pcm_playback_switch(void *handle, const char *switch_id)</H4>

<p>
Returns index for switch with name <i>switch_id</i>. Function returns switch
index if successful, otherwise it returns an error code.

<p>

<H4>int snd_pcm_playback_switch_read(void *handle int switchnsnd_pcm_switch_t *data)</H4>

<p>
Fills the <i>*data</i> structure with data about switch with index <i>switchn</i>.
Function returns zero if successful, otherwise it returns an error code. 

<p>

<DL compact>   <dt><b></b></dt>
	<dd>
<i>/*&nbsp;0&nbsp;or&nbsp;1&nbsp;(enable&nbsp;member&nbsp;of&nbsp;union)&nbsp;*/</i>

<p>
#define&nbsp;SND_PCM_SW_TYPE_BOOLEAN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0

<p>
<i>/*&nbsp;0&nbsp;to&nbsp;255&nbsp;-&nbsp;from&nbsp;low&nbsp;to&nbsp;high&nbsp;(data8[0]&nbsp;member&nbsp;of&nbsp;union)&nbsp;*/</i>

<p>
#define&nbsp;SND_PCM_SW_TYPE_BYTE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1

<p>
<i>/*&nbsp;0&nbsp;to&nbsp;65535&nbsp;-&nbsp;from&nbsp;low&nbsp;to&nbsp;high&nbsp;(data16[0]&nbsp;member&nbsp;of&nbsp;union)&nbsp;*/</i>

<p>
#define&nbsp;SND_PCM_SW_TYPE_WORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2

<p>
<i>/*&nbsp;0&nbsp;to&nbsp;4294967296&nbsp;&#175; &nbsp;from&nbsp;low&nbsp;to&nbsp;high&nbsp;(data32[0]&nbsp;member&nbsp;of&nbsp;union)&nbsp;*/</i>

<p>
#define&nbsp;SND_PCM_SW_TYPE_DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3

<p>
<i>/*&nbsp;user&nbsp;type&nbsp;-&nbsp;no&nbsp;type&nbsp;control&nbsp;*/</i>

<p>
#define&nbsp;SND_PCM_SW_TYPE_USER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&#126;0)
</DL>
<p>
&nbsp;

<p>

<DL compact>   <dt><b></b></dt>
	<dd>
struct&nbsp;snd_pcm_switch&nbsp;{

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>/*&nbsp;switch&nbsp;index&nbsp;(filled&nbsp;by&nbsp;application)&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;switchn;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>/*&nbsp;identification&nbsp;of&nbsp;switch&nbsp;(for&nbsp;driver)&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;name[32];

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>/*&nbsp;type&nbsp;of&nbsp;switch&nbsp;value&nbsp;&#175; &nbsp;See&nbsp;SND_PCM_SW_TYPE_XXXX&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;type;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>/*&nbsp;low&nbsp;range&nbsp;value&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;low;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>/*&nbsp;high&nbsp;range&nbsp;value&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;high;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;union&nbsp;{

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;enable;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>/*&nbsp;0&nbsp;=&nbsp;off&nbsp;1&nbsp;=&nbsp;on&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;data8[32];&nbsp;&nbsp;&nbsp;&nbsp;<i>/*&nbsp;8-bit&nbsp;data&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;short&nbsp;data16[16];&nbsp;&nbsp;<i>/*&nbsp;16-bit&nbsp;data&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;data32[8];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>/*&nbsp;32-bit&nbsp;data&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;value;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>/*&nbsp;reserved&nbsp;for&nbsp;future&nbsp;use&nbsp;&#175; &nbsp;must&nbsp;be&nbsp;zero&nbsp;!!!&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;reserved[32];

<p>
}
</DL>
<p>

<H4>int snd_pcm_playback_switch_write(void *handle int switchnsnd_pcm_switch_t *data)</H4>

<p>
Writes the <i>*data</i> structure with data about switch with index <i>switchn</i>
to kernel. Function returns zero if successful, otherwise it returns an error
code. 

<p>

<H4>int snd_pcm_record_switches(void *handle)</H4>

<p>
Returns count of PCM record switches. In this context 'switch' means universal
control interface between kernel and application which allows various types
of control. Function returns count if successful, otherwise it returns an error
code. Return value should be zero if sound card doesn't have any PCM record
switch.

<p>

<H4>int snd_pcm_record_switch(void *handle, const char *switch_id)</H4>

<p>
Returns index for switch with name <i>switch_id</i>. Function returns switch
index if successful, otherwise it returns an error code.

<p>

<H4>int snd_pcm_record_switch_read(void *handle int switchn snd_pcm_switch_t
*data)</H4>

<p>
Fills the <i>*data</i> structure with data about switch with index <i>switchn</i>.
Function returns zero if successful, otherwise it returns an error code.

<p>

<H4>int snd_pcm_record_switch_write(void *handle int switchnsnd_pcm_switch_t *data)</H4>

<p>
Writes the <i>*data</i> structure with data about switch with index <i>switchn</i>
to kernel. Function returns zero if successful, otherwise it returns an error
code. 

<p>

<H4>int snd_pcm_playback_format(void *handle, snd_pcm_format_t *format)</H4>

<p>
Sets up format, rate (in Hz) and number of channels for playback, in the desired
direction. Function returns zero if successful, otherwise it returns an error
code.

<p>

<DL compact>   <dt><b></b></dt>
	<dd>
struct&nbsp;snd_pcm_format&nbsp;{

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;format;&nbsp;&nbsp;&nbsp;&nbsp;<i>/*&nbsp;SND_PCM_SFMT_XXXX&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;rate;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>/*&nbsp;rate&nbsp;in&nbsp;Hz&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;channels;&nbsp;&nbsp;<i>/*&nbsp;channels&nbsp;(voices)&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;reserved[16];

<p>
};
</DL>
<p>

<H4>int snd_pcm_record_format(void *handle, snd_pcm_format_t *format) </H4>

<p>
Sets up format, rate (in Hz) and number of channels for used for recording in
the specified direction. Function returns zero if successful, otherwise it returns
an error code. 

<p>

<DL compact>   <dt><b></b></dt>
	<dd>
struct&nbsp;snd_pcm_format&nbsp;{

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;format;&nbsp;&nbsp;&nbsp;&nbsp;<i>/*&nbsp;SND_PCM_SFMT_XXXX&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;rate;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>/*&nbsp;rate&nbsp;in&nbsp;Hz&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;channels;&nbsp;&nbsp;<i>/*&nbsp;channels&nbsp;(voices)&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;reserved[16];

<p>
};
</DL>
<p>

<H4>int snd_pcm_playback_params(void *handle, snd_pcm_playback_params_t
*params)</H4>

<p>
Sets various parameters for playback direction. Function returns zero if successful,
otherwise it returns an error code. 

<p>

<DL compact>   <dt><b></b></dt>
	<dd>
struct&nbsp;snd_pcm_playback_params&nbsp;{

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;fragment_size;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;fragments_max;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;fragments_room;

<p>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;reserved&nbsp;for&nbsp;future&nbsp;use&nbsp;-&nbsp;must&nbsp;be&nbsp;filled&nbsp;with&nbsp;zero&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;reserved[16];

<p>
};&nbsp;
</DL>
<p>

<DL compact><dt><b></b></dt>
	<dd> [fragment_size]Requested size of fragment. This value should be aligned for
current format (for example to 4 if stereo 16-bit samples are used) or with
the <i>fragment_align</i> variable from <i>snd_pcm_playback_info_t</i>
structure. Its range can be from <i>min_fragment_size</i> to <i>max_fragment_size</i>.
<dt><b></b></dt>
	<dd> [fragments_max]Maximum number of fragments in queue for wakeup. This number
doesn't include partly used fragments. If the current count of filled playback
fragments is greater than this value the driver will block the application or
return immediately back if non-block mode is active.
<dt><b></b></dt>
	<dd> [fragments_room]Minimum number of fragments writable for wakeup. This value
should in most cases be 1 which means return back to application if at least
one fragment is free for playback. This value includes partly used fragments,
too.
</DL>
<p>

<H4>int snd_pcm_record_params(void *handle, snd_pcm_record_params_t *params)</H4>

<p>
Function sets various parameters for the recording direction. Function returns
zero if successful, otherwise it returns an error code.

<p>

<DL compact>   <dt><b></b></dt>
	<dd>
struct&nbsp;snd_pcm_record_params&nbsp;{

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;fragment_size;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;fragments_min;

<p>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;reserved&nbsp;for&nbsp;future&nbsp;use&nbsp;-&nbsp;must&nbsp;be&nbsp;filled&nbsp;with&nbsp;zero&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;reserved[16];

<p>
};&nbsp;
</DL>
<p>

<DL compact><dt><b></b></dt>
	<dd> [fragment_size]Requested size of fragment. This value should be aligned for
current format (for example to 4 if stereo 16-bit samples are used) or set to
the <i>fragment_align</i> variable from <i>snd_pcm_playback_info_t</i>
structure. Its range can be from <i>min_fragment_size</i> to <i>max_fragment_size</i>.
<dt><b></b></dt>
	<dd> [fragments_min]Minimum filled fragments for wakeup. Driver blocks the application
(if block mode is selected) until input buffer is filled with less than the
number of fragments specified with this value.
</DL>
<p>

<H4>int snd_pcm_playback_status(void *handle, snd_pcm_playback_status_t
*status)</H4>

<p>
Fills the <i>*status</i> structure. Function returns zero if successful,
otherwise it returns an error code.

<p>

<DL compact>   <dt><b></b></dt>
	<dd>
struct&nbsp;snd_pcm_playback_status&nbsp;{

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;rate;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;fragments;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;fragment_size;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;count;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;queue;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;underrun;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;timeval&nbsp;time;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;timeval&nbsp;stime;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;scount;

<p>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;reserved&nbsp;for&nbsp;future&nbsp;use&nbsp;-&nbsp;must&nbsp;be&nbsp;filled&nbsp;with&nbsp;zero&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;reserved[16];

<p>
};
</DL>
<p>

<DL compact><dt><b></b></dt>
	<dd> [rate]Real playback rate. This value reflects hardware limitations. 
<dt><b></b></dt>
	<dd> [fragments]Currently allocated fragments by the driver for playback direction.
<dt><b></b></dt>
	<dd> [fragment_size]Current fragment size used by driver for the playback direction.
<dt><b></b></dt>
	<dd> [count]Count of bytes writable without blocking.
<dt><b></b></dt>
	<dd> [queue]Count of bytes in queue. Note: <i>(fragments*fragment_size) -
queue</i> should not be equal to <i>count</i>.
<dt><b></b></dt>
	<dd> [underrun]This value tells the application the number of underruns since the
last call to <i>snd_pcm_playback_status</i><em>()</em>. 
<dt><b></b></dt>
	<dd> [time]Estimated time when the next written sample will actually be played (time
is always in the future). The estimate is calculated with: current time + sample
queue <em></em>converted to time (number of samples waiting for write to device,
i.e., the same as the <em>queue</em> member above). This value should be used
for time synchronization. Returned value is in the same format as returned from
the standard C function <em>gettimeofday</em>(&amp;<em>time</em>, <em>NULL</em>). This
variable contains valid information only if playback time mode is enabled (see
<i>snd_pcm_playback_time()</i> function). 
<dt><b></b></dt>
	<dd> [stime]Time when playback was started. This variable contains valid information
only if playback time mode is enabled (see <i>snd_pcm_playback_time()</i>
function).
<dt><b></b></dt>
	<dd> [scount]Number of bytes processed (actually played) from playback start. This
number is not necessarily the same as byte count written by application.
</DL>
<p>
 <center><img src="pcmbuf.gif">
<p>
</center> The figure above shows an example situation in the audio playback buffer in
the ALSA driver. The driver splits the audio buffer into 16 <em>fragments</em>,
each being <em>fragment_size</em> bytes long. Fragments 0 and 12-15 are filled
with samples. Fragment 1 is filled partly (about 75%). Driver is playing and
current playback position is in fragment 12 (about 35%). As you can seefree space (structure member <i>count</i>) is counted without including the
fragment which is being played.

<p>

<H4>int snd_pcm_record_status(void *handle, snd_pcm_record_status_t *status)</H4>

<p>
Fills the <i>*status</i> structure. Function returns zero if successful,
otherwise it returns an error code.

<p>

<DL compact>   <dt><b></b></dt>
	<dd>
struct&nbsp;snd_pcm_record_status&nbsp;{

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;rate;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;fragments;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;fragment_size;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;count;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;free;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;overrun;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;timeval&nbsp;time;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;timeval&nbsp;stime;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;scount;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;overrange;

<p>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;reserved&nbsp;for&nbsp;future&nbsp;use&nbsp;-&nbsp;must&nbsp;be&nbsp;filled&nbsp;with&nbsp;zero&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;reserved[16];

<p>
};
</DL>
<p>

<DL compact><dt><b></b></dt>
	<dd> [rate]Real record rate. This value reflects hardware limitations.
<dt><b></b></dt>
	<dd> [fragments]Currently allocated fragments by driver for the record direction.
<dt><b></b></dt>
	<dd> [fragment_size]Current fragment size used by driver for the record direction.
<dt><b></b></dt>
	<dd> [count]Count of bytes readable without blocking.
<dt><b></b></dt>
	<dd> [free]Count of bytes in buffer still free. Note: <i>(fragments*fragment_size)
- free</i> should not be equal to <i>count</i>.
<dt><b></b></dt>
	<dd> [overrun]This value tells application the count of overruns since the last call
to <i>snd_pcm_record_status</i>.
<dt><b></b></dt>
	<dd> [time]Returns a timestamp for the next sample to be read from the record ring
buffer (time is always in the past). The timestamp is calculated with: current
time - sample queue converted to time (waiting for application read() + current
position in fragment is the same as record count + current position in fragment).
This value should be used for time synchronization. Returned value is in the
same format as returned by the standard C function gettimeofday(&amp;time, NULL).
This variable contains right valid information only if record time mode is enabled
(see <i>snd_pcm_record_time()</i> function). 
<dt><b></b></dt>
	<dd> [stime]Time when record was started. This variable contains valid information
only if record time mode is enabled (see <i>snd_pcm_record_time</i> function).
<dt><b></b></dt>
	<dd> [scount]Number of bytes processed (actually recorded) from record start (stime).
This number is not necessarily the same as the byte count read by application.
<dt><b></b></dt>
	<dd> [overrange]ADC overrange count. This value is used only when <i>SND_PCM_RINFO_OVERRANGE</i>
bit in <i>struct snd_pcm_record_info_t-&#62;flags</i> is set (if hardware
supports this feature).
</DL>
<p>
 <center><img src="pcmbuf1.gif">
<p>
</center> The figure above shows an example situation in the audio record buffer in the
ALSA driver. The driver splits the audio buffer into 16 <em>fragments</em>, each
being <em>fragment_size</em> bytes in length. Fragments 0 and 12-15 are filled
with samples. Fragment 1 is partly filled (about 75%) and at the end of the
filled area is the active record position. Data which is ready for the application
begins in fragment 12 (about 35%). As you can see free space (structure
member <i>free</i>) is counted without including the fragment which is partly
filled with samples and the application reads data from this fragment.

<p>

<H4>int snd_pcm_drain_playback(void *handle)</H4>

<p>
This function stops and drains (destroys) the playback buffers immediately.
Function returns zero if successful, otherwise it returns an error code. 

<p>

<H4>int snd_pcm_flush_playback(void *handle)</H4>

<p>
This function flushes the playback buffers. It blocks the program while the
all the waiting samples in kernel playback buffers are processed. Function returns
zero if successful, otherwise it returns an error code.

<p>

<H4>int snd_pcm_flush_record(void *handle)</H4>

<p>
This function flushes (destroys) record buffers. Function returns zero if successful,
otherwise it returns an error code. 

<p>

<H4>int snd_pcm_playback_pause(void *handle int enable)</H4>

<p>
This function pauses playback if <i>enable</i> is non-zero. To restore playing
mode call this function with <i>enable</i> equal to zero. Function returns
zero if successful, otherwise it returns an error code. 

<p>

<H4>int snd_pcm_playback_time(void *handle, int enable)</H4>

<p>
This function enables or disables time mode for the playback direction. Time
mode is useful in synchronizing an application with other events. Function returns
zero if successful, otherwise it returns an error code.

<p>

<H4>int snd_pcm_record_time(void *handle, int enable)</H4>

<p>
This function enables or disables time mode for record direction. Time mode
is useful in synchronizing an application with other events. Function returns
zero if successful, otherwise it returns an error code.

<p>

<H4>ssize_t snd_pcm_write(void *handle, const void *buffer, size_t size)</H4>

<p>
Writes samples to the device which must be in the proper format specified by
the <i>snd_pcm_playback_format</i> function. Function returns zero or positive
value if playback was successful (value represents count of bytes which were
successfully written to device) or an error value if an error occurred. Function
will suspend process if block mode is active.

<p>

<H4>ssize_t snd_pcm_read(void *handle, void *buffer, size_t size)</H4>

<p>
Function reads samples from driver. Samples are in format specified by <i>snd_pcm_record_format</i>
function. Function returns zero or positive value if record was success (value
represents count of bytes which was successfully read from device) or negative
error value if error occurred. Function will suspend process if block mode is
active.

<p>
       <H4><A NAME="tth_sEc5.1.1">
5.1.1</A>&nbsp;&nbsp;Example</H4>

<p>
The following example shows how to play the first 512kB from the /tmp/test.au
file with sound card #0 and PCM device #0:

<p>

<DL compact>   <dt><b></b></dt>
	<dd>
int&nbsp;card&nbsp;=&nbsp;0,&nbsp;device&nbsp;=&nbsp;0,&nbsp;err,&nbsp;fd,&nbsp;count,&nbsp;size,&nbsp;idx;

<p>
void&nbsp;*handle;

<p>
snd_pcm_format_t&nbsp;format;

<p>
char&nbsp;*buffer;
</DL>
<p>
&nbsp;

<p>

<DL compact>   <dt><b></b></dt>
	<dd>
buffer&nbsp;=&nbsp;(char&nbsp;*)malloc(512&nbsp;*&nbsp;1024);

<p>
if&nbsp;(!buffer)&nbsp;return;

<p>
if&nbsp;((err&nbsp;=&nbsp;snd_pcm_open(&amp;handle,&nbsp;card,&nbsp;device,

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SND_PCM_OPEN_PLAYBACK))&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr,&nbsp;"open&nbsp;failed:&nbsp;%s\n",&nbsp;snd_strerror(&nbsp;err&nbsp;));&nbsp;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;

<p>
}

<p>
bzero(&amp;format&nbsp;sizeof(format));

<p>
format.format&nbsp;=&nbsp;SND_PCM_SFMT_MU_LAW;

<p>
format.rate&nbsp;=&nbsp;8000;

<p>
format.channels&nbsp;=&nbsp;1;

<p>
if&nbsp;((err&nbsp;=&nbsp;snd_pcm_playback_format(handle,&nbsp;&amp;format))&nbsp;&lt;&nbsp;0)&nbsp;{

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr,&nbsp;"format&nbsp;setup&nbsp;failed:&nbsp;%s\n",

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;snd_strerror(&nbsp;err&nbsp;));&nbsp;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;snd_pcm_close(&nbsp;handle&nbsp;);

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;

<p>
}

<p>
fd&nbsp;=&nbsp;open("/tmp/test.au",&nbsp;O_RDONLY);

<p>
if&nbsp;(fd&nbsp;&lt;&nbsp;0)&nbsp;{

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;perror("open&nbsp;file");

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;snd_pcm_close(handle);

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;

<p>
}

<p>
idx&nbsp;=&nbsp;0;

<p>
count&nbsp;=&nbsp;read(fd,&nbsp;buffer,&nbsp;512&nbsp;*&nbsp;1024);

<p>
if&nbsp;(count&nbsp;&lt;=&nbsp;0)&nbsp;{

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;perror("read&nbsp;from&nbsp;file");

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;snd_pcm_close(&nbsp;handle&nbsp;);

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;

<p>
}

<p>
close(&nbsp;fd&nbsp;);

<p>
if&nbsp;(!memcmp(buffer,&nbsp;".snd",&nbsp;4))&nbsp;{

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;idx&nbsp;=&nbsp;(buffer[4]&lt;&lt;24)|(buffer[5]&lt;&lt;16)|

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(buffer[6]&lt;&lt;8)|(buffer[7]);

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(idx&nbsp;&#62;&nbsp;128)&nbsp;idx&nbsp;=&nbsp;128;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(idx&nbsp;&#62;&nbsp;count)&nbsp;idx&nbsp;=&nbsp;count;

<p>
}

<p>
size&nbsp;=&nbsp;snd_pcm_write(handle,&nbsp;&amp;buffer[&nbsp;idx&nbsp;],&nbsp;count&nbsp;-&nbsp;idx);

<p>
printf("Bytes&nbsp;written&nbsp;%i&nbsp;from&nbsp;%i...\n",&nbsp;size,&nbsp;count&nbsp;-&nbsp;idx);

<p>
snd_pcm_close(handle);

<p>
free(buffer);
</DL>
<p>
      <H3><A NAME="tth_sEc5.2">
5.2</A>&nbsp;&nbsp;PCM Loopback Interface</H3>

<p>
This interface is designed to pass data currently being played or recorded from
one application to another application for other processing like a graphical
equalizer sample recorder etc... The programmer should be aware that each
loopback connection eats CPU time (for data copying from the process which is
doing the playback or record).

<p>

<H4>int snd_pcm_loopback_open(void **handle, int card, int device, int mode)</H4>

<p>
Creates a new handle and opens a connection to the kernel sound audio loopback
interface for sound card number <i>card</i> (0-N) and audio device number
<i>device</i>. Function also checks if protocol is compatible to prevent use
of old programs with a new kernel API. Function returns zero if successful otherwise
it returns an error code. Error code -EBUSY is returned when another process
owns the selected direction.

<p>
The following modes should be used for the <i>mode</i> argument: 

<p>

<DL compact>   <dt><b></b></dt>
	<dd>
#define&nbsp;SND_PCM_LB_OPEN_PLAYBACK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0

<p>
#define&nbsp;SND_PCM_LB_OPEN_RECORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1
</DL>
<p>

<H4>int snd_pcm_loopback_close(void *handle)</H4>

<p>
Frees all resources allocated with audio handle and closes the connection to
the kernel sound audio interface. Function returns zero if successful, otherwise
it returns an error code.

<p>

<H4>int snd_pcm_loopback_file_descriptor(void *handle)</H4>

<p>
Returns the file descriptor of the connection to the kernel sound audio interface.
Function returns an error code if an error was encountered.

<p>
The file descriptor should be used for the <i>select(2)</i> synchronous multiplexer
function for setting the read direction. Application should call <i>snd_pcm_loopback_read()</i>
function if data is waiting to be read.

<p>

<H4>int snd_pcm_loopback_block_mode(void *handle, int enable) </H4>

<p>
Sets up block (default) or non-block mode for a handle. Block mode suspends
execution of a program when <i>snd_pcm_loopback_read()</i> is called for
the time until some data arrives for file descriptor. In non-block mode, programs
aren't suspended and the above function returns immediately with the count of
bytes which were read by the driver. When used in this way, don't try to use
the entire buffer after the call, but instead process the number of bytes returned,
and call the function again.

<p>

<H4>int snd_pcm_loopback_stream_mode(void *handle, int mode)</H4>

<p>
Sets up stream mode which should be one of these values:

<p>

<DL compact>   <dt><b></b></dt>
	<dd>
#define&nbsp;SND_PCM_LB_STREAM_MODE_RAW&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0

<p>
#define&nbsp;SND_PCM_LB_STREAM_MODE_PACKET&nbsp;&nbsp;1
</DL>
<p>
Mode raw (default mode) means that the stream contains only PCM samples. Packet
mode is more complicated. The stream contains a header at the begining of the
packet. Information like data type and data size is contain in this header.

<p>

<DL compact>   <dt><b></b></dt>
	<dd>
#define&nbsp;SND_PCM_LB_TYPE_DATA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;<i>/*&nbsp;sample&nbsp;data&nbsp;*/</i>

<p>
#define&nbsp;SND_PCM_LB_TYPE_FORMAT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;<i>/*&nbsp;PCM&nbsp;format&nbsp;*/</i>
</DL>
<p>
&nbsp;

<p>

<DL compact>   <dt><b></b></dt>
	<dd>
struct&nbsp;snd_pcm_loopback_header&nbsp;{

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;size;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>/*&nbsp;block&nbsp;size&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;type;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>/*&nbsp;block&nbsp;type&nbsp;(SND_PCM_LB_TYPE_*)&nbsp;*/</i>

<p>
};
</DL>
<p>

<H4>int snd_pcm_loopback_format(void *handle, snd_pcm_format_t *format) </H4>

<p>
Get current format for PCM stream. 

<p>

<DL compact>   <dt><b></b></dt>
	<dd>
struct&nbsp;snd_pcm_format&nbsp;{

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;format;&nbsp;&nbsp;&nbsp;&nbsp;<i>/*&nbsp;SND_PCM_SFMT_XXXX&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;rate;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>/*&nbsp;rate&nbsp;in&nbsp;Hz&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;channels;&nbsp;&nbsp;<i>/*&nbsp;number&nbsp;of&nbsp;channels&nbsp;(voices)&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;reserved[16];

<p>
};
</DL>
<p>

<H4>ssize_t snd_pcm_loopback_read(void *handle, void *buffer, size_t size)</H4>

<p>
This function reads samples or loopback packets from the stream. Data depends
on stream mode which should be set with <i>snd_pcm_loopback_stream_mode()</i>
function. Function returns zero or positive value if record was success (value
represents count of bytes which were successfully read from device) or negative
error value if error occurred. Function will suspend process if block mode is
active.

<p>
        <H2><A NAME="tth_sEc6">
6</A>&nbsp;&nbsp;RawMidi Interface</H2>

<p>
RawMidi Interface is designed to write or read raw (unchanged) MIDI data over
the MIDI line. MIDI stands Musical Instrument Digital Interface and more informations
about this standard can be found at <b>http://www.midi.org</b>.

<p>
      <H3><A NAME="tth_sEc6.1">
6.1</A>&nbsp;&nbsp;Low Level Layer</H3>

<p>
RawMidi devices are opened exclusively for a selected direction. While more
than one process may not open a given MIDI device in the same direction simultaniously,
seperate processes may open a single MIDI device in different directions (i.e.
process one opens a MIDI device in playback direction and process two opens
the same device in record direction). Audio devices (with MIDI ports) return
EBUSY error to applications when other applications have already opened the
requested direction.

<p>

<H4>int snd_rawmidi_open(void **handle, int card, int device, int mode)</H4>

<p>
Creates a new handle and opens a connection to the kernel sound audio interface
for sound card number <i>card</i> (0-N) and rawmidi device number <i>device</i>.
Function also checks if protocol is compatible to prevent use of old programs
with a new kernel API. Function returns zero if successful, otherwise it returns
an error code. Error code -EBUSY is returned when another process owns the selected
direction.

<p>
The following modes should be used for the <i>mode</i> argument: 

<p>

<DL compact>   <dt><b></b></dt>
	<dd>
#define&nbsp;SND_RAWMIDI_OPEN_OUTPUT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(O_WRONLY)

<p>
#define&nbsp;SND_RAWMIDI_OPEN_INPUT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(O_RDONLY)

<p>
#define&nbsp;SND_RAWMIDI_OPEN_DUPLEX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(O_RDWR)
</DL>
<p>

<H4>int snd_rawmidi_close(void *handle)</H4>

<p>
Frees all resources allocated with audio handle and closes the connection to
the kernel sound rawmidi interface. Function returns zero if successful, otherwise
it returns an error code.

<p>

<H4>int snd_rawmidi_file_descriptor(void *handle)</H4>

<p>
Returns the file descriptor of the connection to the kernel sound audio interface.
Function returns an error code if an error was encountered.

<p>
The file descriptor should be used for the <i>select(2)</i> synchronous multiplexer
function for setting the read direction. Application should call <i>snd_rawmidi_read()</i>
or <i>snd_rawmidi_write()</i> functions if data is waiting to be read or
a write can be performed. Calling these functions is highly recommended.

<p>

<H4>int snd_rawmidi_block_mode(void *handle, int enable) </H4>

<p>
Sets up block (default) or non-block mode for a handle. Block mode suspends
execution of a program when <i>snd_rawmidi_read()</i> or <i>snd_rawmidi_write()</i>
is called for the time which is needed for the actual output or input over of
the selected limit. In non-block mode, programs aren't suspended and the above
functions return immediately with the count of bytes which were read or written
by the driver. When used in this way, don't try to use the entire buffer after
the call, but instead process the number of bytes returned, and call the function
again.

<p>

<H4>int snd_rawmidi_info(void *handle, snd_pcm_info_t *info)</H4>

<p>
Fills the <i>*info</i> structure with data about the PCM device selected
by <i>*handle</i>. Function returns zero if successful, otherwise it returns
an error code.

<p>

<DL compact>   <dt><b></b></dt>
	<dd>
<i>/*</i>&nbsp;device&nbsp;is&nbsp;capable&nbsp;rawmidi&nbsp;output&nbsp;*<i>/</i>

<p>
#define&nbsp;SND_RAWMIDI_INFO_OUTPUT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x00000001&nbsp;

<p>
<i>/*&nbsp;device&nbsp;is&nbsp;capable&nbsp;rawmidi&nbsp;input&nbsp;*/</i>

<p>
#define&nbsp;SND_RAWMIDI_INFO_INPUT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x00000002

<p>
<i>/*&nbsp;device&nbsp;is&nbsp;capable&nbsp;duplex&nbsp;mode&nbsp;*/</i>

<p>
#define&nbsp;SND_RAWMIDI_INFO_DUPLEX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x00000004
</DL>
<p>
&nbsp;

<p>

<DL compact>   <dt><b></b></dt>
	<dd>
struct&nbsp;snd_rawmidi_info&nbsp;{

<p>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;sound&nbsp;card&nbsp;type&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;type;

<p>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;see&nbsp;SND_RAWMIDI_INFO_XXXX&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;flags;

<p>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;ID&nbsp;of&nbsp;this&nbsp;PCM&nbsp;device&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;id[32];

<p>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;name&nbsp;of&nbsp;this&nbsp;device&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;name[80];

<p>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;reserved&nbsp;for&nbsp;future&nbsp;use&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;reserved[64];

<p>
};
</DL>
<p>

<H4>int snd_rawmidi_output_info(void *handle, snd_rawmidi_output_info_t
*info)</H4>

<p>
Fills the *info structure with data about rawmidi output. Function returns
zero if successful, otherwise it returns an error code.

<p>

<DL compact>   <dt><b></b></dt>
	<dd>
struct&nbsp;snd_rawmidi_output_info&nbsp;{

<p>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;count&nbsp;of&nbsp;output&nbsp;switches&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;switches;

<p>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;reserved&nbsp;for&nbsp;future&nbsp;use&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;reserved[64];

<p>
};
</DL>
<p>

<H4>int snd_rawmidi_input_info(void *handle, snd_pcm_record_info_t *info)</H4>

<p>
Fills the *info structure. Returns zero if successful, otherwise it returns
an error code. 

<p>

<DL compact>   <dt><b></b></dt>
	<dd>
struct&nbsp;snd_rawmidi_input_info&nbsp;{

<p>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;count&nbsp;of&nbsp;output&nbsp;switches&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;switches;

<p>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;reserved&nbsp;for&nbsp;future&nbsp;use&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;reserved[64];

<p>
};
</DL>
<p>

<H4>int snd_rawmidi_output_switches(void *handle)</H4>

<p>
Returns count of rawmidi output switches. In this context 'switch' means universal
control interface between kernel and application which allows various types
of control. Function returns count if successful, otherwise it returns an error
code. Return value should be zero if sound card doesn't have any rawmidi output
switch.

<p>

<H4>int snd_rawmidi_output_switch(void *handle, const char *switch_id)</H4>

<p>
Returns index for switch with name <i>switch_id</i>. Function returns switch
index if successful, otherwise it returns an error code.

<p>

<H4>int snd_rawmidi_output_switch_read(void *handle int switchnsnd_rawmidi_switch_t *data)</H4>

<p>
Fills the <i>*data</i> structure with data about switch with index <i>switchn</i>.
Function returns zero if successful, otherwise it returns an error code. 

<p>

<DL compact>   <dt><b></b></dt>
	<dd>
<i>/*&nbsp;0&nbsp;or&nbsp;1&nbsp;(enable&nbsp;member&nbsp;of&nbsp;union)&nbsp;*/</i>

<p>
#define&nbsp;SND_PCM_SW_TYPE_BOOLEAN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0

<p>
<i>/*&nbsp;0&nbsp;to&nbsp;255&nbsp;-&nbsp;from&nbsp;low&nbsp;to&nbsp;high&nbsp;(data8[0]&nbsp;member&nbsp;of&nbsp;union)&nbsp;*/</i>

<p>
#define&nbsp;SND_PCM_SW_TYPE_BYTE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1

<p>
<i>/*&nbsp;0&nbsp;to&nbsp;65535&nbsp;-&nbsp;from&nbsp;low&nbsp;to&nbsp;high&nbsp;(data16[0]&nbsp;member&nbsp;of&nbsp;union)&nbsp;*/</i>

<p>
#define&nbsp;SND_PCM_SW_TYPE_WORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2

<p>
<i>/*&nbsp;0&nbsp;to&nbsp;4294967296&nbsp;&#175; &nbsp;from&nbsp;low&nbsp;to&nbsp;high&nbsp;(data32[0]&nbsp;member&nbsp;of&nbsp;union)&nbsp;*/</i>

<p>
#define&nbsp;SND_PCM_SW_TYPE_DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3

<p>
<i>/*&nbsp;user&nbsp;type&nbsp;-&nbsp;no&nbsp;type&nbsp;control&nbsp;*/</i>

<p>
#define&nbsp;SND_PCM_SW_TYPE_USER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&#126;0)
</DL>
<p>
&nbsp;

<p>

<DL compact>   <dt><b></b></dt>
	<dd>
struct&nbsp;snd_rawmidi_switch&nbsp;{

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>/*&nbsp;switch&nbsp;index&nbsp;(filled&nbsp;by&nbsp;application)&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;switchn;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>/*&nbsp;identification&nbsp;of&nbsp;switch&nbsp;(for&nbsp;driver)&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;name[32];

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>/*&nbsp;type&nbsp;of&nbsp;switch&nbsp;value&nbsp;&#175; &nbsp;See&nbsp;SND_PCM_SW_TYPE_XXXX&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;type;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>/*&nbsp;low&nbsp;range&nbsp;value&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;low;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>/*&nbsp;high&nbsp;range&nbsp;value&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;high;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;union&nbsp;{

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;enable;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>/*&nbsp;0&nbsp;=&nbsp;off&nbsp;1&nbsp;=&nbsp;on&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;data8[32];&nbsp;&nbsp;&nbsp;&nbsp;<i>/*&nbsp;8-bit&nbsp;data&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;short&nbsp;data16[16];&nbsp;&nbsp;<i>/*&nbsp;16-bit&nbsp;data&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;data32[8];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>/*&nbsp;32-bit&nbsp;data&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;value;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>/*&nbsp;reserved&nbsp;for&nbsp;future&nbsp;use&nbsp;&#175; &nbsp;must&nbsp;be&nbsp;zero&nbsp;!!!&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;reserved[32];

<p>
}
</DL>
<p>

<H4>int snd_rawmidi_output_switch_write(void *handle int switchnsnd_rawmidi_switch_t *data)</H4>

<p>
Writes the <i>*data</i> structure with data about switch with index <i>switchn</i>
to kernel. Function returns zero if successful, otherwise it returns an error
code. 

<p>

<H4>int snd_rawmidi_input_switches(void *handle)</H4>

<p>
Returns count of rawmidi input switches. In this context 'switch' means universal
control interface between kernel and application which allows various types
of control. Function returns count if successful, otherwise it returns an error
code. Return value should be zero if sound card doesn't have any rawmidi input
switch.

<p>

<H4>int snd_rawmidi_input_switch(void *handle, const char *switch_id)</H4>

<p>
Returns index for switch with name <i>switch_id</i>. Function returns switch
index if successful, otherwise it returns an error code.

<p>

<H4>int snd_rawmidi_input_switch_read(void *handle int switchnsnd_rawmidi_switch_t *data)</H4>

<p>
Fills the <i>*data</i> structure with data about switch with index <i>switchn</i>.
Function returns zero if successful, otherwise it returns an error code.

<p>

<H4>int snd_rawmidi_input_switch_write(void *handle int switchnsnd_rawmidi_switch_t *data)</H4>

<p>
Writes the <i>*data</i> structure with data about switch with index <i>switchn</i>
to kernel. Function returns zero if successful, otherwise it returns an error
code. 

<p>

<H4>int snd_rawmidi_output_params(void *handle, snd_rawmidi_output_params_t
*params)</H4>

<p>
Sets various parameters for output direction. Function returns zero if successful,
otherwise it returns an error code. 

<p>

<DL compact>   <dt><b></b></dt>
	<dd>
struct&nbsp;snd_rawmidi_output_params&nbsp;{

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;size;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;max;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;room;

<p>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;reserved&nbsp;for&nbsp;future&nbsp;use&nbsp;-&nbsp;must&nbsp;be&nbsp;filled&nbsp;with&nbsp;zero&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;reserved[16];

<p>
};&nbsp;
</DL>
<p>

<DL compact><dt><b></b></dt>
	<dd> [size]Requested queue size of output buffer in bytes (default setup is 4096
[i386] or 8192 [alpha] bytes - this is system architecture dependent).
<dt><b></b></dt>
	<dd> [max]Maximum number of bytes in queue for wakeup. If the current byte count
of filled portion of output buffer is greater than this value the driver will
block an application or return immediately if non block mode is active.
<dt><b></b></dt>
	<dd> [room]Minimum number of bytes writable for wakeup. This value should be in most
cases 1 which means return back to application if at least one byte is free
in output buffer.
</DL>
<p>

<H4>int snd_rawmidi_input_params(void *handle, snd_rawmidi_input_params_t
*params)</H4>

<p>
Function sets various parameters for the recording direction. Function returns
zero if successful, otherwise it returns an error code.

<p>

<DL compact>   <dt><b></b></dt>
	<dd>
struct&nbsp;snd_rawmidi_input_params&nbsp;{

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;size;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;min;

<p>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;reserved&nbsp;for&nbsp;future&nbsp;use&nbsp;-&nbsp;must&nbsp;be&nbsp;filled&nbsp;with&nbsp;zero&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;reserved[16];

<p>
};&nbsp;
</DL>
<p>

<DL compact><dt><b></b></dt>
	<dd> [size]Requested queue size of input buffer in bytes (default setup is 4096 [i386]
or 8192 [alpha] bytes - this is system architecture dependent).
<dt><b></b></dt>
	<dd> [min]Minimum filled bytes in queue for wakeup. Driver blocks the application
(if block mode is selected) until input buffer is filled with fewer than the
number of bytes specified with this value.
</DL>
<p>

<H4>int snd_rawmidi_output_status(void *handle, snd_rawmidi_output_status_t
*status)</H4>

<p>
Fills the <i>*status</i> structure. Function returns zero if successful,
otherwise it returns an error code.

<p>

<DL compact>   <dt><b></b></dt>
	<dd>
struct&nbsp;snd_rawmidi_output_status&nbsp;{

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;size;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;count;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;queue;

<p>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;reserved&nbsp;for&nbsp;future&nbsp;use&nbsp;-&nbsp;must&nbsp;be&nbsp;filled&nbsp;with&nbsp;zero&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;reserved[16];

<p>
};
</DL>
<p>

<DL compact><dt><b></b></dt>
	<dd> [size]Size of currently allocated queue in bytes.
<dt><b></b></dt>
	<dd> [count]Count of bytes writable without blocking.
<dt><b></b></dt>
	<dd> [queue]Count of bytes in queue (number of bytes waiting to be output).
</DL>
<p>

<H4>int snd_rawmidi_input_status(void *handle, snd_rawmidi_input_status_t
*status)</H4>

<p>
Fills the <i>*status</i> structure. Function returns zero if successful,
otherwise it returns an error code.

<p>

<DL compact>   <dt><b></b></dt>
	<dd>
struct&nbsp;snd_rawmidi_input_status&nbsp;{

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;size;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;count;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;free;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;overrun;

<p>
<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;reserved&nbsp;for&nbsp;future&nbsp;use&nbsp;-&nbsp;must&nbsp;be&nbsp;filled&nbsp;with&nbsp;zero&nbsp;*/</i>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;reserved[16];

<p>
};
</DL>
<p>

<DL compact><dt><b></b></dt>
	<dd> [size]Size of currently allocated queue in bytes.
<dt><b></b></dt>
	<dd> [count]Count of bytes readable without blocking.
<dt><b></b></dt>
	<dd> [free]Count of bytes in queue still free.
<dt><b></b></dt>
	<dd> [overrun]This value tells the application the count of overruns since the last
call to <i>snd_rawmidi_input_status</i>.
</DL>
<p>

<H4>int snd_rawmidi_drain_output(void *handle)</H4>

<p>
This function stops and drains (destroys) the output queue immediately. Function
returns zero if successful, otherwise it returns an error code. 

<p>

<H4>int snd_rawmidi_flush_output(void *handle)</H4>

<p>
This function flushes the output queue. It blocks the program while the all
the waiting bytes in kernel output queue are processed. Function returns zero
if successful, otherwise it returns an error code.

<p>

<H4>int snd_rawmidi_flush_input(void *handle)</H4>

<p>
This function flushes (destroys) input queue. Function returns zero if successful,
otherwise it returns an error code. 

<p>

<H4>ssize_t snd_rawmidi_write(void *handle, const void *buffer, size_t
size)</H4>

<p>
Writes bytes to the output queue. Function returns zero or positive value if
the write was successful (value represents count of bytes which were successfully
written to the device) or an error value if error occurred. Function will suspend
the process if block mode is active.

<p>

<H4>ssize_t snd_rawmidi_read(void *handle, void *buffer, size_t size)</H4>

<p>
Function reads bytes from input queue. Function returns zero or positive value
if the read was successful (value represents count of bytes which were successfully
read from device) or negative error value if error occurred. Function will suspend
the process if block mode is active.

<p>
       <H4><A NAME="tth_sEc6.1.1">
6.1.1</A>&nbsp;&nbsp;Example</H4>

<p>
The following example shows how to send a control sequence (such as SysEx) to
a MIDI device. Sound card #0 and rawmidi device #0 are used here:

<p>

<DL compact>   <dt><b></b></dt>
	<dd>
int&nbsp;card&nbsp;=&nbsp;0,&nbsp;device&nbsp;=&nbsp;0,&nbsp;err,&nbsp;fd,&nbsp;count,&nbsp;size;

<p>
void&nbsp;*handle;

<p>
snd_pcm_format_t&nbsp;format;

<p>
char&nbsp;*buffer;
</DL>
<p>
&nbsp;

<p>

<DL compact>   <dt><b></b></dt>
	<dd>
buffer&nbsp;=&nbsp;(char&nbsp;*)malloc(64&nbsp;*&nbsp;1024);

<p>
if&nbsp;(!buffer)&nbsp;return;

<p>
if&nbsp;((err&nbsp;=&nbsp;snd_rawmidi_open(&amp;handle,&nbsp;card,&nbsp;device,

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SND_RAWMIDI_OPEN_OUTPUT))&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr,&nbsp;"open&nbsp;failed:&nbsp;%s\n",&nbsp;snd_strerror(&nbsp;err&nbsp;));&nbsp;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;

<p>
}

<p>
if&nbsp;((err&nbsp;=&nbsp;snd_rawmidi_block_mode(handle&nbsp;1))&nbsp;&lt;&nbsp;0)&nbsp;{

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr,&nbsp;"block&nbsp;failed:&nbsp;%s\n",&nbsp;snd_strerror(&nbsp;err&nbsp;));&nbsp;

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;snd_rawmidi_close(handle);

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;

<p>
}

<p>
fd&nbsp;=&nbsp;open("/tmp/test.sysex",&nbsp;O_RDONLY);

<p>
if&nbsp;(fd&nbsp;&lt;&nbsp;0)&nbsp;{

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;perror("open&nbsp;file");

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;snd_rawmidi_close(handle);

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;

<p>
}

<p>
idx&nbsp;=&nbsp;0;

<p>
count&nbsp;=&nbsp;read(fd,&nbsp;buffer,&nbsp;64&nbsp;*&nbsp;1024);

<p>
if&nbsp;(count&nbsp;&lt;=&nbsp;0)&nbsp;{

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;perror("read&nbsp;from&nbsp;file");

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;snd_rawmidi_close(handle);

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;

<p>
}

<p>
close(fd);

<p>
size&nbsp;=&nbsp;snd_rawmidi_write(handle,&nbsp;&amp;buffer,&nbsp;count);

<p>
printf("Bytes&nbsp;written&nbsp;%i&nbsp;from&nbsp;%i...\n",&nbsp;size,&nbsp;count);

<p>
snd_rawmidi_close(handle);

<p>
free(buffer);

<p>
</DL>
<p><hr><small>File translated from T<sub><font size="-1">E</font></sub>X by <a href="http://hutchinson.belmont.ma.us/tth/">T<sub><font size="-1">T</font></sub>H</a>, version 1.98.<br>On 19 Jan 1999, 16:22.</small>
</HTML>
